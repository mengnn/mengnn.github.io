<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孟繁胜游 ● 技术博客</title>
  
  <subtitle>前端开发工程师</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mengnn.cn/"/>
  <updated>2025-04-18T06:14:25.236Z</updated>
  <id>https://mengnn.cn/</id>
  
  <author>
    <name>孟繁胜游</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从Flex布局向Grid布局迁移：全面解析 CSS Grid 的核心用法</title>
    <link href="https://mengnn.cn/%E4%BB%8E%20Flex%20%E5%B8%83%E5%B1%80%E5%90%91%20Grid%20%E5%B8%83%E5%B1%80%E8%BD%AC%E7%A7%BB/"/>
    <id>https://mengnn.cn/从 Flex 布局向 Grid 布局转移/</id>
    <published>2025-04-18T05:49:46.907Z</published>
    <updated>2025-04-18T06:14:25.236Z</updated>
    
    <content type="html"><![CDATA[<p>在响应式设计成为标配的今天，CSS布局技术经历了从浮动（Float）到弹性盒子（Flexbox），再到网格（Grid）的演进过程。Flex 布局（Flexbox）作为一维布局解决方案，擅长处理单行或单列的弹性布局场景，例如导航栏、卡片列表等。但随着 Web 界面复杂度的提升，当需要处理二维布局（同时涉及行和列的对齐）时，Flex 布局的局限性逐渐显现：</p><ul><li><strong>单维度控制</strong>：Flex只能处理行或列单一方向的布局</li><li><strong>隐式定位</strong>：元素位置依赖order属性调整</li><li><strong>尺寸计算的不可控性</strong>：flex-grow/shrink的复杂计算逻辑</li><li><strong>嵌套地狱</strong>：复杂布局需要多层flex容器嵌套</li></ul><a id="more"></a><p>CSS Grid 布局（Grid Layout）作为二维布局的终极解决方案，于 2017 年全面进入浏览器稳定支持阶段。它通过 “网格容器 - 网格项目” 的模型，提供了更强大的二维空间控制能力，特别适合：</p><ul><li><strong>真正的二维布局</strong>：同时控制行和列</li><li><strong>显式网格系统</strong>：明确定义布局结构</li><li><strong>精准定位</strong>：任意元素可跨越行列</li><li><strong>响应式原生支持</strong>：无需媒体查询实现自适应</li></ul><h2 id="Grid-核心概念"><a href="#Grid-核心概念" class="headerlink" title="Grid 核心概念"></a>Grid 核心概念</h2><h3 id="网格体系结构"><a href="#网格体系结构" class="headerlink" title="网格体系结构"></a>网格体系结构</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="built_in">repeat</span>(3, 1fr) <span class="number">200px</span>;  <span class="comment">/* 显式列定义 */</span></span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">minmax</span>(50px, auto) <span class="number">300px</span>;      <span class="comment">/* 显式行定义 */</span></span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">20px</span>;                            <span class="comment">/* 现代间距方案 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>fr 单位</strong>：弹性轨道单位，1fr 表示剩余空间的等份分配</li><li><strong>minmax(min, max)</strong>：定义轨道的最小 / 最大尺寸，支持百分比、px、fr 等单位</li><li><strong>repeat () 函数</strong>：重复定义轨道模式，支持参数repeat(次数, 模式)</li></ul><h4 id="核心术语对照表："><a href="#核心术语对照表：" class="headerlink" title="核心术语对照表："></a>核心术语对照表：</h4><table><thead><tr><th align="left">Flex概念</th><th align="left">Grid对应概念</th><th align="left">升级点</th></tr></thead><tbody><tr><td align="left">flex-container</td><td align="left">grid-container</td><td align="left">二维控制能力</td></tr><tr><td align="left">main-axis</td><td align="left">grid-line</td><td align="left">精确的网格线定位</td></tr><tr><td align="left">flex-item</td><td align="left">grid-item</td><td align="left">跨越行列的能力</td></tr><tr><td align="left">flex-wrap</td><td align="left">auto-placement</td><td align="left">智能的自动排列策略</td></tr></tbody></table><h2 id="从Flex到Grid的思维转换"><a href="#从Flex到Grid的思维转换" class="headerlink" title="从Flex到Grid的思维转换"></a>从Flex到Grid的思维转换</h2><h3 id="布局逻辑的维度"><a href="#布局逻辑的维度" class="headerlink" title="布局逻辑的维度"></a>布局逻辑的维度</h3><h4 id="Flex布局思维"><a href="#Flex布局思维" class="headerlink" title="Flex布局思维"></a>Flex布局思维</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 典型flex导航栏 */</span></span><br><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Grid等效实现"><a href="#Grid等效实现" class="headerlink" title="Grid等效实现"></a>Grid等效实现</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: auto <span class="number">1</span>fr auto; <span class="comment">/* 左logo 中间隙 右菜单 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性对照"><a href="#属性对照" class="headerlink" title="属性对照"></a>属性对照</h4><table><thead><tr><th align="left">Flex属性</th><th align="left">Grid替代方案</th><th align="left">优势</th></tr></thead><tbody><tr><td align="left">flex-direction</td><td align="left">grid-auto-flow</td><td align="left">支持行列双向流动</td></tr><tr><td align="left">flex-wrap</td><td align="left">auto-fit/auto-fill</td><td align="left">智能填充算法</td></tr><tr><td align="left">justify-content</td><td align="left">justify-items</td><td align="left">单元格内容对齐</td></tr><tr><td align="left">align-items</td><td align="left">align-content</td><td align="left">整体网格对齐</td></tr><tr><td align="left">margin: auto</td><td align="left">grid-area定位</td><td align="left">精准的跨区域定位</td></tr></tbody></table><h2 id="Grid布局的杀手锏特性"><a href="#Grid布局的杀手锏特性" class="headerlink" title="Grid布局的杀手锏特性"></a>Grid布局的杀手锏特性</h2><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card-grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fit, minmax(300px, 1fr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数解析："><a href="#参数解析：" class="headerlink" title="参数解析："></a>参数解析：</h4><ul><li><code>auto-fit</code>：智能填充可用空间</li><li><code>minmax(300px, 1fr)</code>：响应式宽度约束</li><li>无需媒体查询即可实现：<ul><li>桌面端多列布局</li><li>移动端单列布局</li><li>中间状态的完美过渡</li></ul></li></ul><h3 id="复杂布局降"><a href="#复杂布局降" class="headerlink" title="复杂布局降"></a>复杂布局降</h3><h4 id="传统Flex实现（圣杯布局）："><a href="#传统Flex实现（圣杯布局）：" class="headerlink" title="传统Flex实现（圣杯布局）："></a><strong>传统Flex实现（圣杯布局）</strong>：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span>, <span class="selector-class">.footer</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; &#125;</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123; <span class="attribute">width</span>: <span class="number">200px</span>; &#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123; <span class="attribute">flex</span>: <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="Grid优雅方案："><a href="#Grid优雅方案：" class="headerlink" title="Grid优雅方案："></a><strong>Grid优雅方案</strong>：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template</span>: </span><br><span class="line">    <span class="string">"header header"</span> <span class="number">80px</span></span><br><span class="line">    <span class="string">"sidebar main"</span> <span class="number">1</span>fr</span><br><span class="line">    <span class="string">"footer footer"</span> <span class="number">60px</span></span><br><span class="line">    / <span class="number">200px</span> <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flex-vs-Grid"><a href="#Flex-vs-Grid" class="headerlink" title="Flex vs Grid"></a>Flex vs Grid</h2><h3 id="适用场景对比"><a href="#适用场景对比" class="headerlink" title="适用场景对比"></a>适用场景对比</h3><table><thead><tr><th align="left">布局类型</th><th align="left">推荐技术</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left">一维线性布局</td><td align="left">Flex</td><td align="left">简单列表、导航栏</td></tr><tr><td align="left">二维复杂布局</td><td align="left">Grid</td><td align="left">仪表盘、卡片网格、表单布局</td></tr><tr><td align="left">内部元素对齐</td><td align="left">Flex</td><td align="left">单个容器内的元素对齐</td></tr><tr><td align="left">整体页面架构</td><td align="left">Grid</td><td align="left">头部/主体/侧边栏/页脚的定位</td></tr></tbody></table><h3 id="混合布局范例"><a href="#混合布局范例" class="headerlink" title="混合布局范例"></a>混合布局范例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template</span>: </span><br><span class="line">    <span class="string">"nav nav"</span> <span class="number">60px</span></span><br><span class="line">    <span class="string">"sidebar main"</span> <span class="number">1</span>fr</span><br><span class="line">    / <span class="number">240px</span> <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card-group</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><h3 id="现代浏览器支持度"><a href="#现代浏览器支持度" class="headerlink" title="现代浏览器支持度"></a>现代浏览器支持度</h3><ul><li>Chrome 57+、Firefox 52+、Edge 16+、Safari 10+ 已全面支持</li><li>旧版浏览器（如 IE11）可通过 Autoprefixer 添加前缀：display: -ms-grid;</li></ul><h3 id="开发工具辅助"><a href="#开发工具辅助" class="headerlink" title="开发工具辅助"></a>开发工具辅助</h3><ul><li>Chrome DevTools 的 Grid Inspector 可视化网格结构</li><li>Firefox 的 Grid 布局调试工具</li><li>使用 PostCSS 插件自动补全语法</li></ul><p>Flex 布局与 Grid 布局并非互斥关系，而是互补的布局工具：Flex 专注于一维布局的灵活性，Grid 擅长二维空间的精确控制。现代 Web 开发中，推荐采用 “外层 Grid 定框架，内层 Flex 做细节” 的混合布局策略。</p><p>掌握 Grid 布局不仅能提升复杂界面的开发效率，更能建立二维空间的布局思维。随着 CSS Subgrid（子网格）等新特性的逐步落地，Grid 布局的潜力还将持续释放。建议开发者从基础案例开始实践，逐步过渡到复杂场景，让 Grid 成为响应式设计的核心工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在响应式设计成为标配的今天，CSS布局技术经历了从浮动（Float）到弹性盒子（Flexbox），再到网格（Grid）的演进过程。Flex 布局（Flexbox）作为一维布局解决方案，擅长处理单行或单列的弹性布局场景，例如导航栏、卡片列表等。但随着 Web 界面复杂度的提升，当需要处理二维布局（同时涉及行和列的对齐）时，Flex 布局的局限性逐渐显现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单维度控制&lt;/strong&gt;：Flex只能处理行或列单一方向的布局&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐式定位&lt;/strong&gt;：元素位置依赖order属性调整&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尺寸计算的不可控性&lt;/strong&gt;：flex-grow/shrink的复杂计算逻辑&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;嵌套地狱&lt;/strong&gt;：复杂布局需要多层flex容器嵌套&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="css3" scheme="https://mengnn.cn/tags/css3/"/>
    
      <category term="Grid" scheme="https://mengnn.cn/tags/Grid/"/>
    
      <category term="Flex" scheme="https://mengnn.cn/tags/Flex/"/>
    
      <category term="css布局" scheme="https://mengnn.cn/tags/css%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>七牛云+PicGo搭建图床教程</title>
    <link href="https://mengnn.cn/%E4%B8%83%E7%89%9B%E4%BA%91%E9%85%8D%E5%90%88PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%E6%95%99%E7%A8%8B/"/>
    <id>https://mengnn.cn/七牛云配合PicGo搭建图床教程/</id>
    <published>2025-04-09T05:58:00.938Z</published>
    <updated>2025-04-18T06:17:00.526Z</updated>
    
    <content type="html"><![CDATA[<p>使用Markdown写文案时，每次上传图片都只能是本地的，发布内容到线上时图片总显示不出来，而图床可以说完美解决这一问题。</p><p>PicGo 是一款开源的图片上传与管理工具，专注于帮助用户快速将本地图片上传到云端图床，并生成可直接使用的图片链接。它支持多种主流图床服务（如七牛云、腾讯云、GitHub、阿里云等），并提供了简洁的界面和高效的自动化操作，尤其适合博客作者、开发者、文档写作者等需要频繁插入图片的用户。</p><p>市面上图床比较多，免费和收费的都有。 七牛云在其中算是口碑较好的<strong>免费图床</strong>。PicGo配合七牛云上传图片到云端算是相对较好的一种解决方案。下面是关于PicGo使用七牛云配置图床的详细教程。（如果已经有七牛云账户，可直接跳到下面PicGo详细配置）</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1-注册七牛云"><a href="#1-注册七牛云" class="headerlink" title="1.注册七牛云"></a>1.注册七牛云</h3><p>要想实现通过PicGo上传图片到七牛云，首先得有一个七牛云账户，七牛云提供个人免费的存储空间，所以针对于个人来说基本不花钱。<a href="https://s.qiniu.com/JRvIjm" target="_blank" rel="noopener">点击七牛云官网注册</a>。</p><h3 id="2-创建存储空间（Bucket）"><a href="#2-创建存储空间（Bucket）" class="headerlink" title="2.创建存储空间（Bucket）"></a>2.创建存储空间（Bucket）</h3><ul><li>登录七牛云控制台，进入 <strong>对象存储</strong> → <strong>空间管理</strong> → <strong>创建空间</strong>。</li><li>输入存储空间名称（如 <code>my-picbed</code>），选择区域（如华东-浙江），访问控制选择 <strong>公开空间</strong>（便于外链访问）。</li></ul><p><img src="https://cdn.mengxyz.com/blog/20250409161937564.png" alt></p><h3 id="3-获取-Access-Key-和-Secret-Key"><a href="#3-获取-Access-Key-和-Secret-Key" class="headerlink" title="3.获取 Access Key 和 Secret Key"></a>3.获取 Access Key 和 Secret Key</h3><ul><li><p>进入七牛云控制台，点击右上角个人头像 → <strong>密钥管理</strong>，复制 <code>AK</code> 和 <code>SK</code>（后续配置 PicGo 需要）。</p><p><img src="https://cdn.mengxyz.com/blog/20250409161650130.png" alt="图片"></p></li></ul><h3 id="4-绑定自定义域名（可选但推荐）"><a href="#4-绑定自定义域名（可选但推荐）" class="headerlink" title="4.绑定自定义域名（可选但推荐）"></a>4.绑定自定义域名（可选但推荐）</h3><ul><li>七牛云默认提供测试域名（30天有效期），长期使用建议绑定自己的域名。</li><li>进入存储空间 → <strong>域名管理</strong> → <strong>绑定域名</strong>，按提示完成域名解析（需在域名服务商处添加 CNAME 记录）。</li></ul><h2 id="安装并配置-PicGo"><a href="#安装并配置-PicGo" class="headerlink" title="安装并配置 PicGo"></a>安装并配置 PicGo</h2><p>完成前期关于七牛云的准备工作后，进入到PicGo的安装配置工作。</p><h3 id="1-下载安装PicGO"><a href="#1-下载安装PicGO" class="headerlink" title="1.下载安装PicGO"></a>1.下载安装PicGO</h3><p>进入到<a href="https://picgo.github.io/PicGo-Doc/zh/guide/#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">PicGo官方下载页面</a>，点击下载链接即可下载对应系统版本的PicGo安装包（支持 Windows、Mac、Linux）。目前提供的下载链接还是蛮多的，国内使用Github链接可能下载会比较慢，但下载总有办法。</p><p><img src="https://cdn.mengxyz.com/blog/20250409162030814.png" alt></p><p>截止到写这篇文章的时候，PicGo已经更新到<code>[2.4.0-beta.9]</code>，而正式版为<code>2.3.1</code>。根据你的喜欢可以选择beta版本，也可以选择正式版。</p><p><img src="https://cdn.mengxyz.com/blog/20250409162050602.png" alt></p><p>下载完成后，双击安装包，按照流程安装即可。</p><p><img src="https://cdn.mengxyz.com/blog/20250409162102268.png" alt></p><h3 id="2-配置PicGo"><a href="#2-配置PicGo" class="headerlink" title="2.配置PicGo"></a>2.配置PicGo</h3><p>启动PicGo客户端，首次进去可以看到PicGo默认上传的配置为SM.MS方式，点击<strong>图床设置</strong> → <strong>七牛云</strong> → <strong>编辑小图标</strong>，进入到七牛云设置页面。</p><p><img src="https://cdn.mengxyz.com/blog/20250409162158039.png" alt></p><p>按照要求依次填入下面信息：</p><ul><li><strong>AccessKey</strong> 和 <strong>SecretKey</strong>：粘贴七牛云的 AK 和 SK。</li><li><strong>设定Bucket</strong>：填写之前创建的存储空间名称（如 <code>my-picbed</code>）。</li><li><strong>设定访问地址</strong>：填写七牛云提供的测试域名或已绑定的自定义域名（如 <code>http://xxx.your-domain.com</code>）。</li><li><strong>设定存储区域</strong>：根据创建存储空间时选择的区域填写代码（华东 <code>z0</code>，华北 <code>z1</code>，华南 <code>z2</code>，北美 <code>na0</code>，东南亚 <code>as0</code>）。</li><li><strong>设定存储路径</strong>：如果你在存储空间内创建了文件夹，可以指定图片上传到该文件夹内（如<code>images/</code>），非必填。</li></ul><p>配置完成后点击下面确定按钮，然后点击<strong>设为默认图床</strong>即完成所有配置。</p><p><img src="https://cdn.mengxyz.com/blog/20250409162213344.png" alt></p><h2 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h2><p>所有配置完成后，即可测试上传图片。</p><p>点击左侧导航<strong>上传区</strong>，点击<strong>上传</strong>，上传成功后的链接默认在剪切板呢，可以直接粘贴使用。</p><p>点击左侧导航<strong>图片</strong>，即可查看你上传成功的图片。</p><p><img src="https://cdn.mengxyz.com/blog/20250409162234245.png" alt></p><p><strong>注意</strong>：如果上传失败，大多数情况下原因是配置的存储区域代码有误，你可以检查一下自己的存储空间的区域是什么，然后可以在七牛云<a href="https://developer.qiniu.com/kodo/1671/region-endpoint-fq" target="_blank" rel="noopener">存储区域开发文档中</a>查看对应的区域代码。</p><p><img src="https://cdn.mengxyz.com/blog/20250409162247808.png" alt></p><h2 id="拓展-PicGo-的核心功能"><a href="#拓展-PicGo-的核心功能" class="headerlink" title="拓展-PicGo 的核心功能"></a>拓展-PicGo 的核心功能</h2><h3 id="1-一键上传图片到云端"><a href="#1-一键上传图片到云端" class="headerlink" title="1.一键上传图片到云端"></a>1.一键上传图片到云端</h3><ul><li>支持拖拽上传、剪贴板上传、快捷键上传，自动生成图片外链。</li><li>上传后链接自动复制到剪贴板，可直接粘贴到 Markdown、HTML 或文档中。</li></ul><h3 id="2-多图床支持"><a href="#2-多图床支持" class="headerlink" title="2.多图床支持"></a>2.多图床支持</h3><ul><li>内置 <strong>七牛云、腾讯云 COS、阿里云 OSS、GitHub、SM.MS、Imgur</strong> 等主流图床。</li><li>支持通过插件扩展更多图床（如 Gitee、又拍云、自定义 WebDAV 等）。</li></ul><h3 id="3-跨平台兼容"><a href="#3-跨平台兼容" class="headerlink" title="3.跨平台兼容"></a>3.跨平台兼容</h3><ul><li>支持 Windows、macOS、Linux 系统，提供图形化界面和命令行工具（CLI）。</li></ul><h3 id="4-高级功能"><a href="#4-高级功能" class="headerlink" title="4.高级功能"></a>4.高级功能</h3><ul><li><strong>批量上传</strong>：一次性上传多张图片，生成链接列表。</li><li><strong>自定义链接格式</strong>：添加图片处理参数（如调整尺寸、压缩、水印）。</li><li><strong>相册管理</strong>：查看历史上传记录，删除或重新复制链接。</li><li><strong>Typora 集成</strong>：与 Markdown 编辑器 Typora 无缝配合，实现“粘贴即上传”。</li></ul><h3 id="5-插件系统"><a href="#5-插件系统" class="headerlink" title="5.插件系统"></a>5.插件系统</h3><ul><li>支持安装插件增强功能，例如：<ul><li><strong>picgo-plugin-watermark</strong>：上传时自动添加水印。</li><li><strong>picgo-plugin-rename-file</strong>：自定义上传后的文件名。</li><li><strong>picgo-plugin-super-prefix</strong>：自动生成存储路径。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Markdown写文案时，每次上传图片都只能是本地的，发布内容到线上时图片总显示不出来，而图床可以说完美解决这一问题。&lt;/p&gt;
&lt;p&gt;PicGo 是一款开源的图片上传与管理工具，专注于帮助用户快速将本地图片上传到云端图床，并生成可直接使用的图片链接。它支持多种主流图床服务（如七牛云、腾讯云、GitHub、阿里云等），并提供了简洁的界面和高效的自动化操作，尤其适合博客作者、开发者、文档写作者等需要频繁插入图片的用户。&lt;/p&gt;
&lt;p&gt;市面上图床比较多，免费和收费的都有。 七牛云在其中算是口碑较好的&lt;strong&gt;免费图床&lt;/strong&gt;。PicGo配合七牛云上传图片到云端算是相对较好的一种解决方案。下面是关于PicGo使用七牛云配置图床的详细教程。（如果已经有七牛云账户，可直接跳到下面PicGo详细配置）&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="https://mengnn.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="七牛云" scheme="https://mengnn.cn/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
      <category term="PicGo" scheme="https://mengnn.cn/tags/PicGo/"/>
    
      <category term="图床" scheme="https://mengnn.cn/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>好玩的css锥形渐变conic-gradient</title>
    <link href="https://mengnn.cn/%E8%AF%A6%E8%A7%A3css%E9%94%A5%E5%BD%A2%E6%B8%90%E5%8F%98/"/>
    <id>https://mengnn.cn/详解css锥形渐变/</id>
    <published>2025-04-08T07:46:44.872Z</published>
    <updated>2025-04-08T09:04:56.443Z</updated>
    
    <content type="html"><![CDATA[<p><code>conic-gradient</code>是 CSS 中用于创建锥形渐变效果的函数。与线性渐变（linear-gradient）和径向渐变（radial-gradient）不同，<code>conic-gradient</code> 是 CSS 中一种围绕中心点按角度方向渐变的颜色过渡效果，就像一个色轮一样。颜色从起始角度开始，沿顺时针方向环绕中心分布。</p><p><img src="https://cdn.mengxyz.com/blog/20250408-l8.gif" alt="加载动画"></p><a id="more"></a><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><strong>起始角度</strong>：可选，默认 <code>0deg</code>（12 点钟方向），如 <code>from 90deg</code> 表示从 3 点钟方向开始。</li><li><strong>中心点位置</strong>：可选，默认 <code>at center</code>，如 <code>at 20% 80%</code> 定义渐变的中心点。</li><li><strong>颜色断点</strong>：颜色值 + 位置（百分比或角度），如 <code>red 0%, blue 30%</code>。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">conic-gradient</span>(</span><br><span class="line">  <span class="selector-attr">[from &lt;起始角度&gt;]</span> </span><br><span class="line">  <span class="selector-attr">[at &lt;中心点位置&gt;]</span>,</span><br><span class="line">  &lt;颜色断点1&gt; <span class="selector-attr">[&lt;位置&gt;]</span>,</span><br><span class="line">  &lt;颜色断点2&gt; <span class="selector-attr">[&lt;位置&gt;]</span>,</span><br><span class="line">  ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*例如*/</span></span><br><span class="line"><span class="comment">/* 简单的三色锥形渐变 */</span></span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">conic-gradient</span>(red, yellow, blue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定起始角度和中心点的锥形渐变 */</span></span><br><span class="line"><span class="selector-class">.element2</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">conic-gradient</span>(from 45deg at 20% 30%, red, yellow, blue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>conic-gradient</code>属性可以实现很多复杂且好看的效果，比如常见的加载指示器、饼图、色轮、透明网格背景效果等。</p><h3 id="加载指示器"><a href="#加载指示器" class="headerlink" title="加载指示器"></a>加载指示器</h3><p>可以根据不同的配置，生成各种加载效果</p><h4 id="1-简单的加载效果"><a href="#1-简单的加载效果" class="headerlink" title="1.简单的加载效果"></a>1.简单的加载效果</h4><p><img src="https://cdn.mengxyz.com/blog/20250408-l1.gif" alt="加载动画"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.loader</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">conic-gradient</span>(#e5e5e5 0% 80%, #2196f3 80%);</span><br><span class="line">    <span class="attribute">mask</span>: <span class="built_in">radial-gradient</span>(transparent 55%, #000 56%);</span><br><span class="line">    <span class="comment">/* 挖空中心 */</span></span><br><span class="line">    <span class="attribute">animation</span>: rotate <span class="number">1s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> rotate &#123;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(360deg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-渐变偏移动画"><a href="#2-渐变偏移动画" class="headerlink" title="2.渐变偏移动画"></a>2.渐变偏移动画</h4><p><img src="https://cdn.mengxyz.com/blog/20250408-l2.gif" alt="加载动画"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.loader-offset</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>:</span><br><span class="line">        <span class="built_in">conic-gradient</span>(#ff4757, #ffa502, #2ed573, #1e90ff, #ff4757);</span><br><span class="line">    <span class="attribute">mask</span>: <span class="built_in">radial-gradient</span>(transparent 50%, #000 61%);</span><br><span class="line">    <span class="attribute">animation</span>:</span><br><span class="line">        rotate <span class="number">1.5s</span> linear infinite,</span><br><span class="line">        bgShift <span class="number">3s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> bgShift &#123;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: <span class="number">400%</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-离散的圆点围绕环形加载"><a href="#3-离散的圆点围绕环形加载" class="headerlink" title="3.离散的圆点围绕环形加载"></a>3.离散的圆点围绕环形加载</h4><p><img src="https://cdn.mengxyz.com/blog/20250408-l3.gif" alt="加载动画"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.loader-dots</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: </span><br><span class="line">    <span class="built_in">conic-gradient</span>(</span><br><span class="line">      #3498db 0% 10%, </span><br><span class="line">      transparent 10% 20%,</span><br><span class="line">      #3498db 20% 30%,</span><br><span class="line">      transparent 30% 40%,</span><br><span class="line">      #3498db 40% 50%,</span><br><span class="line">      transparent 50% 60%,</span><br><span class="line">      #3498db 60% 70%,</span><br><span class="line">      transparent 70% 80%,</span><br><span class="line">      #3498db 80% 90%,</span><br><span class="line">      transparent 90%</span><br><span class="line">    );</span><br><span class="line">  <span class="attribute">animation</span>: rotate <span class="number">1s</span> linear infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网格背景"><a href="#网格背景" class="headerlink" title="网格背景"></a>网格背景</h3><p><img src="https://cdn.mengxyz.com/blog/20250408-l4.png" alt="网格背景"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.checkerboard</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">conic-gradient</span>(#eee 25%, #444 0% 50%, #eee 0% 75%, #444 0%);</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>background-size</code> 平铺锥形渐变，利用硬边断点创建方格。</p><h3 id="饼图（Pie-Chart）"><a href="#饼图（Pie-Chart）" class="headerlink" title="饼图（Pie Chart）"></a>饼图（Pie Chart）</h3><p><img src="https://cdn.mengxyz.com/blog/20250408-l5.png" alt="饼图"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pie-chart</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">conic-gradient</span>(</span><br><span class="line">    #ff6b6b 0% 30%,</span><br><span class="line">    #4ecdc4 30% 70%,</span><br><span class="line">    #45b7d1 70% 100%</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成三色饼图，颜色分界线清晰。颜色断点使用相同起止位置（如 <code>30%</code>）实现硬边。</p><h3 id="色轮"><a href="#色轮" class="headerlink" title="色轮"></a>色轮</h3><p><img src="https://cdn.mengxyz.com/blog/20250408-l6.png" alt="色轮"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.color-wheel</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">conic-gradient</span>(</span><br><span class="line">    hsl(0, 100%, 50%),</span><br><span class="line">    <span class="built_in">hsl</span>(60, 100%, 50%),</span><br><span class="line">    <span class="built_in">hsl</span>(120, 100%, 50%),</span><br><span class="line">    <span class="built_in">hsl</span>(180, 100%, 50%),</span><br><span class="line">    <span class="built_in">hsl</span>(240, 100%, 50%),</span><br><span class="line">    <span class="built_in">hsl</span>(300, 100%, 50%),</span><br><span class="line">    <span class="built_in">hsl</span>(360, 100%, 50%)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合 <code>hsl()</code> 函数实现色相自然过渡。</p><h3 id="渐变按钮"><a href="#渐变按钮" class="headerlink" title="渐变按钮"></a>渐变按钮</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.glow-button</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">conic-gradient</span>(</span><br><span class="line">    from 180deg,</span><br><span class="line">    #ff8a00,</span><br><span class="line">    #e52e71,</span><br><span class="line">    #00f2fe,</span><br><span class="line">    #4facfe,</span><br><span class="line">    #ff8a00</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展-repaeting-conic-gradient"><a href="#拓展-repaeting-conic-gradient" class="headerlink" title="拓展 repaeting-conic-gradient"></a>拓展 repaeting-conic-gradient</h3><p><code>repeating-conic-gradient</code>与 <code>conic-gradient</code> 类似，但颜色断点会<strong>无限重复</strong>，直到填充满整个区域。</p><h4 id="条纹背景"><a href="#条纹背景" class="headerlink" title="条纹背景"></a>条纹背景</h4><p><img src="https://cdn.mengxyz.com/blog/20250408-l7.png" alt="条纹背景"></p><p>每 <code>30deg</code> 重复一次红蓝条纹（15°红色 + 15°蓝色）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.stripes</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">repeating-conic-gradient</span>(</span><br><span class="line">    #ff6b6b 0deg 15deg,</span><br><span class="line">    #4ecdc4 15deg 30deg</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;conic-gradient&lt;/code&gt;是 CSS 中用于创建锥形渐变效果的函数。与线性渐变（linear-gradient）和径向渐变（radial-gradient）不同，&lt;code&gt;conic-gradient&lt;/code&gt; 是 CSS 中一种围绕中心点按角度方向渐变的颜色过渡效果，就像一个色轮一样。颜色从起始角度开始，沿顺时针方向环绕中心分布。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.mengxyz.com/blog/20250408-l8.gif&quot; alt=&quot;加载动画&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="css3" scheme="https://mengnn.cn/tags/css3/"/>
    
      <category term="渐变" scheme="https://mengnn.cn/tags/%E6%B8%90%E5%8F%98/"/>
    
      <category term="conic-gradient" scheme="https://mengnn.cn/tags/conic-gradient/"/>
    
  </entry>
  
  <entry>
    <title>详解css3过渡属性transition</title>
    <link href="https://mengnn.cn/%E8%AF%A6%E8%A7%A3css3%E8%BF%87%E6%B8%A1%E5%B1%9E%E6%80%A7transition/"/>
    <id>https://mengnn.cn/详解css3过渡属性transition/</id>
    <published>2025-03-25T03:34:46.880Z</published>
    <updated>2025-03-25T07:07:32.736Z</updated>
    
    <content type="html"><![CDATA[<p>实现html页面动画的方式有很多种，而css3中的过渡属性<code>transition</code>也是实现动画效果的高频工具。</p><p><code>transition</code> 属性允许 CSS 的属性值在一定的时间区间内平滑地过渡。当元素的某个 CSS 属性值发生变化时，过渡效果可以避免属性值的突然改变，而是以动画的形式逐渐变化，从而增强用户体验。</p><p><img src="https://cdn.mengxyz.com/blog/20250325.gif" alt="transition动画"></p><a id="more"></a><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>transition</code> 是一个简写属性，它可以一次性设置四个过渡相关的属性，四个属性值分别对应<code>transition-property</code>（指定要应用过渡的 CSS 属性）、<code>transition-duration</code>（定义过渡动画总时长）、<code>transition-timing-function</code>（定义动画速度曲线）、<code>transition-delay</code>（设置动画开始前的等待时间）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*复合写法*/</span> </span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">property</span> <span class="selector-tag">duration</span> <span class="selector-tag">timing-function</span> <span class="selector-tag">delay</span>;</span><br></pre></td></tr></table></figure><h3 id="参数1：transition-property"><a href="#参数1：transition-property" class="headerlink" title="参数1：transition-property"></a>参数1：transition-property</h3><p><strong>property：</strong>对应的是<code>transition-property</code>，指定要应用过渡效果的 CSS 属性名称。</p><p>可以是单个属性，如 <code>width</code>、<code>opacity</code> 等；也可以是多个属性，用逗号分隔，如 <code>width, height</code>；还可以使用 <code>all</code> 表示所有可过渡的属性。</p><h3 id="参数2：transition-duration"><a href="#参数2：transition-duration" class="headerlink" title="参数2：transition-duration"></a>参数2：transition-duration</h3><p><strong>duration</strong>：定义过渡效果持续的时间，以秒（s）或毫秒（ms）为单位。例如 <code>2s</code> 表示过渡持续 2 秒。</p><h3 id="参数3：transition-timing-function"><a href="#参数3：transition-timing-function" class="headerlink" title="参数3：transition-timing-function"></a>参数3：transition-timing-function</h3><p><strong>timing-function</strong>：指定过渡效果的时间曲线，即过渡的速度变化方式。常见的值有：</p><ul><li><code>ease</code>：默认值，过渡开始时较慢，然后加速，结束时又变慢。</li><li><code>linear</code>：过渡速度保持一致。</li><li><code>ease-in</code>：过渡开始时较慢，然后逐渐加速。</li><li><code>ease-out</code>：过渡开始时较快，然后逐渐减速。</li><li><code>ease-in-out</code>：过渡开始和结束时较慢，中间加速。</li><li><code>cubic-bezier(0.25, 0.1, 0.25, 1.0)</code>（对应 <code>ease</code>）`：自定义贝塞尔曲线，通过四个数值来精确控制过渡的速度变化。</li><li>阶梯函数：<code>steps(5, jump-start)</code>（用于离散动画）</li></ul><h3 id="参数4：transition-delay"><a href="#参数4：transition-delay" class="headerlink" title="参数4：transition-delay"></a>参数4：transition-delay</h3><p><strong>delay</strong>：定义过渡效果开始前的延迟时间，同样以秒（s）或毫秒（ms）为单位。例如 <code>1s</code> 表示过渡将在 1 秒后开始。</p><ul><li><strong>负值特性</strong>：<code>-500ms</code> 会使动画从中途开始（需总时长 &gt; 延迟绝对值）</li></ul><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><ol><li><strong>触发条件</strong>：必须由 <strong>状态变更</strong> 引发（如 <code>:hover</code> 伪类、JS 修改 class/样式）</li><li><strong>插值计算</strong>：浏览器根据起始/结束值和持续时间，计算中间帧属性值</li><li><strong>渲染管线</strong>：<ul><li>触发 CSS 解析 → 样式重算 → 布局（Layout）→ 绘制（Paint）→ 合成（Composite）</li><li>优化建议：优先使用 <code>transform</code>/<code>opacity</code> 触发合成层动画，避免重排</li></ul></li></ol><p><strong>注意：</strong>父元素的 <code>transition</code> 设置不会继承到子元素；同一元素的相同属性被多个 <code>transition</code> 定义时，后定义的生效；当状态还原时，自动执行反向过渡（除非中途被中断）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现html页面动画的方式有很多种，而css3中的过渡属性&lt;code&gt;transition&lt;/code&gt;也是实现动画效果的高频工具。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;transition&lt;/code&gt; 属性允许 CSS 的属性值在一定的时间区间内平滑地过渡。当元素的某个 CSS 属性值发生变化时，过渡效果可以避免属性值的突然改变，而是以动画的形式逐渐变化，从而增强用户体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.mengxyz.com/blog/20250325.gif&quot; alt=&quot;transition动画&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="css3" scheme="https://mengnn.cn/tags/css3/"/>
    
      <category term="transition" scheme="https://mengnn.cn/tags/transition/"/>
    
  </entry>
  
  <entry>
    <title>Set和Map用法详解</title>
    <link href="https://mengnn.cn/Set%E5%92%8CMap%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://mengnn.cn/Set和Map用法详解/</id>
    <published>2025-03-03T08:41:44.598Z</published>
    <updated>2025-03-03T08:51:07.991Z</updated>
    
    <content type="html"><![CDATA[<p><code>Set</code>  和 <code>Map</code>是 ES6 中引入的两种新的数据结构。提供了更强大和灵活的数据存储与操作方式。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>Set</code>是一种集合数据结构，它允许存储任何类型的唯一值，无论是基本数据类型还是对象引用。</p><p><strong>特点：</strong></p><a id="more"></a><ul><li>唯一性：集合中的每个值都是唯一的，重复的值会被自动忽略。</li><li>无序性：<code>Set</code>中的元素没有特定的顺序，不能通过索引来访问元素。</li></ul><p><strong>常用方法：</strong></p><ul><li><code>add(value)</code>：向<code>Set</code>中添加一个新元素，如果元素已存在，则不会重复添加。</li><li><code>delete(value)</code>：从<code>Set</code>中删除指定元素，如果元素存在则返回<code>true</code>，否则返回<code>false</code>。</li><li><code>has(value)</code>：检查<code>Set</code>中是否存在指定元素，存在返回<code>true</code>，否则返回<code>false</code>。</li><li><code>size</code>：返回<code>Set</code>中元素的数量。</li></ul><p><strong>基本用法：</strong></p><h3 id="1-创建一个Set实例并添加元素。"><a href="#1-创建一个Set实例并添加元素。" class="headerlink" title="1.创建一个Set实例并添加元素。"></a>1.创建一个<code>Set</code>实例并添加元素。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">mySet.add(<span class="number">1</span>);</span><br><span class="line">mySet.add(<span class="number">2</span>);</span><br><span class="line">mySet.add(<span class="number">2</span>); <span class="comment">// 重复元素不会被添加</span></span><br><span class="line"><span class="built_in">console</span>.log(mySet); <span class="comment">// Set &#123;1, 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(mySet.size) <span class="comment">//返回元素的数量： 2</span></span><br></pre></td></tr></table></figure><h3 id="2-可迭代"><a href="#2-可迭代" class="headerlink" title="2.可迭代"></a>2.可迭代</h3><p><code>Set</code>可以通过<code>for...of</code>循环直接迭代其值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> mySet) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次输出：1 2 3</span></span><br></pre></td></tr></table></figure><h3 id="3-数组去重"><a href="#3-数组去重" class="headerlink" title="3.数组去重"></a>3.数组去重</h3><p>利用<code>Set</code>的唯一性对数组进行去重。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> uniqueArr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line"><span class="built_in">console</span>.log(uniqueArr) <span class="comment">// [1,2,3,4,8]</span></span><br></pre></td></tr></table></figure><h3 id="4-交集、并集、差集运算"><a href="#4-交集、并集、差集运算" class="headerlink" title="4.交集、并集、差集运算"></a>4.交集、并集、差集运算</h3><p>在处理多个数据集合的关系时，<code>Set</code>可以配合一些数组的方法很容易地进行交集、并集和差集等数学运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">const</span> intersection = <span class="keyword">new</span> <span class="built_in">Set</span>([...setA].filter(<span class="function"><span class="params">x</span> =&gt;</span> setB.has(x)));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(intersection)); <span class="comment">// [4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">const</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...setA,...setB]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(union)); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">const</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...setA].filter(<span class="function"><span class="params">x</span> =&gt;</span>!setB.has(x)));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(difference)); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>Map</code>是一种键值对的数据结构，它可以将任何类型的值（包括对象）作为键和值进行存储。</p><p><strong>特点：</strong></p><ul><li><code>键的多样性</code>：<code>Map</code>的键可以是任意类型，而不像传统的 JavaScript 对象那样，键只能是字符串或符号。</li><li><code>有序性</code>：<code>Map</code>中的键值对是按照插入的顺序进行存储的，这意味着可以按照插入的顺序来遍历<code>Map</code>。</li></ul><p><strong>常用方法：</strong></p><ul><li><code>set(key, value)</code>：向<code>Map</code>中添加一个新的键值对，如果键已存在，则更新其对应的值。</li><li><code>get(key)</code>：根据指定的键获取对应的值，如果键不存在，则返回<code>undefined</code>。</li><li><code>has(key)</code>：检查<code>Map</code>中是否存在指定的键，存在返回<code>true</code>，否则返回<code>false</code>。</li><li><code>delete(key)</code>：从<code>Map</code>中删除指定键的键值对，如果键存在并成功删除，则返回<code>true</code>，否则返回<code>false</code>。</li><li><code>size</code>：返回<code>Map</code>中键值对的数量。</li></ul><p><strong>基本用法：</strong></p><h3 id="1-创建Map实例并设置键值对。"><a href="#1-创建Map实例并设置键值对。" class="headerlink" title="1.创建Map实例并设置键值对。"></a>1.创建<code>Map</code>实例并设置键值对。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="string">'name'</span>, <span class="string">'John'</span>);</span><br><span class="line">myMap.set(<span class="string">'age'</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myMap) <span class="comment">// Map &#123;'name' =&gt; 'John', 'age' =&gt; 30&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(myMap.get(<span class="string">'name'</span>)); <span class="comment">// John</span></span><br></pre></td></tr></table></figure><h3 id="2-可迭代-1"><a href="#2-可迭代-1" class="headerlink" title="2.可迭代"></a>2.可迭代</h3><p><code>Map</code>同样可以通过<code>for...of</code>循环迭代其键值对，每个迭代的值是一个包含键和值的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>, <span class="number">10</span>], [<span class="string">'key2'</span>, <span class="number">20</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次输出：['key1', 10]   ['key2', 20]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次输出：key1 10   key2 20</span></span><br></pre></td></tr></table></figure><h3 id="3-对象映射"><a href="#3-对象映射" class="headerlink" title="3.对象映射"></a>3.对象映射</h3><p>将一个对象的属性映射到另一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'Alice'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(person, <span class="string">'active'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(1) &#123;&#123;…&#125; =&gt; 'active'&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(person)); <span class="comment">// active</span></span><br></pre></td></tr></table></figure><h3 id="4-数据缓存"><a href="#4-数据缓存" class="headerlink" title="4.数据缓存"></a>4.数据缓存</h3><p>在开发单页应用（SPA）时，经常需要从服务器获取数据。为了提高性能，减少不必要的网络请求，可以使用<code>Map</code>来缓存已经获取的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataCache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataCache.has(url)) &#123;</span><br><span class="line">        <span class="keyword">return</span> dataCache.get(url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line">    dataCache.set(url, data);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Set&lt;/code&gt;  和 &lt;code&gt;Map&lt;/code&gt;是 ES6 中引入的两种新的数据结构。提供了更强大和灵活的数据存储与操作方式。&lt;/p&gt;
&lt;h2 id=&quot;Set&quot;&gt;&lt;a href=&quot;#Set&quot; class=&quot;headerlink&quot; title=&quot;Set&quot;&gt;&lt;/a&gt;Set&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Set&lt;/code&gt;是一种集合数据结构，它允许存储任何类型的唯一值，无论是基本数据类型还是对象引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Set" scheme="https://mengnn.cn/tags/Set/"/>
    
      <category term="Map" scheme="https://mengnn.cn/tags/Map/"/>
    
      <category term="ES6" scheme="https://mengnn.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>字符串常用方法</title>
    <link href="https://mengnn.cn/Js%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://mengnn.cn/Js中字符串常用方法/</id>
    <published>2025-02-21T02:05:33.810Z</published>
    <updated>2025-02-24T07:20:16.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-replace-和-replaceAll"><a href="#1-replace-和-replaceAll" class="headerlink" title="1.replace 和 replaceAll"></a>1.replace 和 replaceAll</h2><p><code>replace()</code>替换字符串中的部分内容，返回一个新字符串，原始的字符串不会改变。</p><p><strong>语法：</strong><code>replace(pattern, replacement)</code></p><p><strong>参数：</strong></p><a id="more"></a><p><code>pattern</code>：需要替换的内容，可以是字符串或者一个带有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/replace" target="_blank" rel="noopener"><code>Symbol.replace</code></a> 方法的对象，典型的例子就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_expressions" target="_blank" rel="noopener">正则表达式</a>。</p><p><code>replacement</code>：可以是字符串或函数。如果是字符串，它将替换由 <code>pattern</code> 匹配的子字符串；如果是函数，将为每个匹配调用该函数，并将其返回值用作替换文本。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello,hello"</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.replace(<span class="string">"h"</span>,<span class="string">"H"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newStr) <span class="comment">// Hello,hello</span></span><br><span class="line"><span class="comment">// 注意：如果使用正则表达式并带 g 标志，可以全局替换。</span></span><br><span class="line"><span class="keyword">let</span> newStr2 = str.replace(<span class="regexp">/h/g</span>,<span class="string">"H"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newStr2) <span class="comment">// Hello,Hello</span></span><br></pre></td></tr></table></figure><p><code>replaceAll()</code>同上，替换所有满足<code>pattern</code>的部分，返回一个新字符串。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello,hello"</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.replaceAll(<span class="string">"h"</span>,<span class="string">"H"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newStr) <span class="comment">// Hello,Hello</span></span><br></pre></td></tr></table></figure><h2 id="2-includes"><a href="#2-includes" class="headerlink" title="2.includes"></a>2.includes</h2><p>判断字符串是否包含指定的子字符串，返回布尔值。</p><p><strong>语法：</strong><code>includes(searchString)</code>  <code>includes(searchString, position)</code></p><p><strong>参数：</strong></p><p><code>searchString</code>：一个要在 <code>str</code> 中查找的字符串。如果该参数被省略或传入 <code>undefined</code>，<code>includes()</code> 方法会在字符串中搜索 <code>&quot;undefined&quot;</code>。</p><p><code>position（选填）</code>：在字符串中开始搜索 <code>searchString</code> 的位置。默认值为 <code>0</code>。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello,hello"</span>;</span><br><span class="line"><span class="keyword">let</span> hasWorld  = str.includes(<span class="string">"hello"</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="3-split"><a href="#3-split" class="headerlink" title="3.split"></a>3.split</h2><p>将字符串按<code>某种模式</code>分割成一个数组，并返回该数组。</p><p><strong>语法：</strong><code>split(separator, limit)</code></p><p><strong>参数：</strong></p><p><code>separator</code>：分隔符，即按照<strong>separator</strong>这种模式的分隔符进行分割，可以为<strong>undefined</strong></p><p><code>limit（可选）</code>：一个非负整数，指定数组中包含的子字符串的数量限制。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"Hello,World!"</span>;</span><br><span class="line"><span class="keyword">const</span> arr = str.split(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">const</span> arr2 = str.split(<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// 输出: ['Hello', 'World!']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// 输出: ['H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd', '!']</span></span><br></pre></td></tr></table></figure><h2 id="4-slice"><a href="#4-slice" class="headerlink" title="4.slice"></a>4.slice</h2><p>从指定的 <code>indexStart</code> 开始提取到 <code>indexEnd</code>（不包含）的子字符串。如果省略 <code>indexEnd</code>，则提取到字符串末尾。可以使用负数索引从字符串末尾开始计数。</p><p><strong>语法：</strong><code>slice(indexStart, indexEnd)</code></p><p><strong>参数：</strong></p><p><code>indexStart</code>：要返回的子字符串中包含的第一个字符的索引（索引从0开始）。</p><p><code>indexEnd（可选）</code>：要返回的子字符串中最后一个字符的索引。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"Hello,World!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">0</span>, <span class="number">5</span>)); <span class="comment">// 输出: Hello</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">6</span>));    <span class="comment">// 输出: World!</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">-6</span>));   <span class="comment">// 输出: World!</span></span><br></pre></td></tr></table></figure><h2 id="5-substring"><a href="#5-substring" class="headerlink" title="5.substring"></a>5.substring</h2><p>提取指定字符串，与 <code>slice</code> 类似，但不支持负数索引。如果 <code>indexStart</code> 大于 <code>indexEnd</code>，它会自动交换两个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"Hello,World!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">0</span>, <span class="number">5</span>)); <span class="comment">// 输出: Hello</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">6</span>));    <span class="comment">// 输出: World!</span></span><br></pre></td></tr></table></figure><h2 id="6-indexOf"><a href="#6-indexOf" class="headerlink" title="6.indexOf"></a>6.indexOf</h2><p>返回 <code>searchString</code> 在字符串中第一次出现的索引位置（从0开始），如果未找到则返回 -1。<code>startIndex</code> 是可选的，表示开始查找的位置。</p><p><strong>语法：</strong><code>indexOf(searchString, startIndex)</code></p><p><strong>参数：</strong></p><p><code>searchString</code>：要搜索的子字符串。所有传入值都会被强制转换为字符串，因此如果该参数被省略或传入 <code>undefined</code>，<code>indexOf()</code> 方法会在字符串中搜索 <code>&quot;undefined&quot;</code>。</p><p><code>startIndex（可选）</code>：开始查找字符串的位置，默认为 <code>0</code>。如果 <code>startIndex</code> 大于调用字符串的长度，则该方法根本不搜索调用字符串。如果 <code>startIndex</code> 小于零，该方法的行为就像 <code>startIndex</code> 为 <code>0</code> 时一样。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"Hello,World!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">"l"</span>)); <span class="comment">// 输出: 2</span></span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">"abc"</span>));   <span class="comment">// 输出: -1</span></span><br></pre></td></tr></table></figure><h2 id="7-startsWith"><a href="#7-startsWith" class="headerlink" title="7.startsWith"></a>7.startsWith</h2><p>用来判断当前字符串是否以另外一个给定的子字符串开头，返回一个布尔值。</p><p><strong>语法：</strong><code>startsWith(searchString, startIndex)</code></p><p><strong>参数：</strong></p><p><code>searchString</code>：要在该字符串开头搜索的子串。</p><p><code>startIndex（可选）</code>：<code>searchString</code> 期望被找到的起始位置（即 <code>searchString</code> 的第一个字符的索引）。默认为 <code>0</code>。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"Hello,World!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">"Hello"</span>)); <span class="comment">// 输出: true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">"H"</span>)); <span class="comment">// 输出: true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">"H"</span>,<span class="number">1</span>)); <span class="comment">// 输出: false</span></span><br></pre></td></tr></table></figure><h2 id="8-endsWith"><a href="#8-endsWith" class="headerlink" title="8.endsWith"></a>8.endsWith</h2><p>同上，<code>endsWith(searchValue, length)</code>返回一个布尔值，表示字符串是否以 <code>searchValue</code> 结尾。<code>length</code> 是可选的，表示检查的字符串长度。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"Hello,World!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">"World!"</span>)); <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure><h2 id="9-toUpperCase-和-toLowerCase"><a href="#9-toUpperCase-和-toLowerCase" class="headerlink" title="9.toUpperCase 和 toLowerCase"></a>9.toUpperCase 和 toLowerCase</h2><p><code>toUpperCase()</code>：将字符串转换为大写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"Hello, World!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.toUpperCase()); <span class="comment">// 输出: HELLO, WORLD!</span></span><br></pre></td></tr></table></figure><p><code>toLowerCase()</code>：将字符串转换为小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const str = &quot;Hello, World!&quot;;</span><br><span class="line">console.log(str.toLowerCase()); // 输出: hello, world!</span><br></pre></td></tr></table></figure><h2 id="10-padStart"><a href="#10-padStart" class="headerlink" title="10.padStart"></a>10.padStart</h2><p>用另一个字符串填充当前字符串（如果需要会重复填充），直到达到给定的长度。填充是从当前字符串的开头开始的。</p><p><strong>语法：</strong><code>padStart(targetLength, padString)</code></p><p><strong>参数：</strong></p><p><code>targetLength</code>：当前 <code>str</code> 填充后的长度。如果该值小于或等于 <code>str.length</code>，则会直接返回当前 <code>str</code>。</p><p><code>padString（可选）</code>：用于填充当前 <code>str</code> 的字符串。如果 <code>padString</code> 太长，无法适应 <code>targetLength</code>，则会从末尾被截断。默认值为 Unicode“空格”字符（U+0020）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"8"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.padStart(<span class="number">2</span>,<span class="string">'0'</span>)) <span class="comment">// 输出: 08</span></span><br><span class="line"><span class="built_in">console</span>.log(str.padStart(<span class="number">8</span>,<span class="string">'01'</span>)) <span class="comment">// 输出: 01010108</span></span><br></pre></td></tr></table></figure><h2 id="11-trim-和-trimEnd"><a href="#11-trim-和-trimEnd" class="headerlink" title="11.trim 和 trimEnd"></a>11.trim 和 trimEnd</h2><p><code>trim()</code> 方法会从字符串的两端移除空白字符，并返回一个新的字符串，而不会修改原始字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"   Hello world!   "</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.trim()) <span class="comment">// 输出："Hello world!"</span></span><br></pre></td></tr></table></figure><p><code>trimEnd()</code>方法会从字符串的结尾移除空白字符，并返回一个新的字符串，而不会修改原始字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"   Hello world!   "</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.trimEnd()) <span class="comment">// 输出："   Hello world!"</span></span><br></pre></td></tr></table></figure><h2 id="12-repeat"><a href="#12-repeat" class="headerlink" title="12.repeat"></a>12.repeat</h2><p>指定字符串重复出现的次数。</p><p><strong>语法：</strong><code>repeat(count)</code></p><p><strong>参数：</strong></p><p><code>count</code>：介于 <code>0</code> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY" target="_blank" rel="noopener"><code>+Infinity</code></a> 之间的整数。表示在新构造的字符串中重复了多少遍原字符串。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"Happy！"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">2</span>)) <span class="comment">// 输出：Happy！Happy！</span></span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">0</span>)) <span class="comment">// 输出：''</span></span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">2.8</span>)) <span class="comment">// 输出：Happy！Happy！</span></span><br></pre></td></tr></table></figure><h2 id="13-charAt"><a href="#13-charAt" class="headerlink" title="13.charAt"></a>13.charAt</h2><p>返回指定索位置的字符。</p><p><strong>语法：</strong><code>charAt(index)</code></p><p><strong>参数：</strong></p><p><code>index</code>：要返回字符的索引，从零开始。会被转换为整数，<code>undefined</code> 会被转换为 0。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"Hello World!"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">1</span>)) <span class="comment">// 输出：e</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charAt()) <span class="comment">// 输出：H</span></span><br></pre></td></tr></table></figure><h2 id="14-concat"><a href="#14-concat" class="headerlink" title="14.concat"></a>14.concat</h2><p>连接字符串（合并字符串），并返回一个新的字符串。</p><p><strong>语法：</strong><code>concat(str1)</code>、<code>concat(str1,str2)</code>、<code>concat(str1, str2, /* …, */ strN)</code></p><p><strong>参数：</strong>需要合并的字符串</p><p><strong>示例：</strong>    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">'Hello'</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">"World"</span></span><br><span class="line"><span class="keyword">const</span> str3 = <span class="string">"!"</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.concat(str2)) <span class="comment">// 输出：HelloWorld</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.concat(str2,str3)) <span class="comment">// 输出：HelloWorld!</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-replace-和-replaceAll&quot;&gt;&lt;a href=&quot;#1-replace-和-replaceAll&quot; class=&quot;headerlink&quot; title=&quot;1.replace 和 replaceAll&quot;&gt;&lt;/a&gt;1.replace 和 replaceAll&lt;/h2&gt;&lt;p&gt;&lt;code&gt;replace()&lt;/code&gt;替换字符串中的部分内容，返回一个新字符串，原始的字符串不会改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;code&gt;replace(pattern, replacement)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://mengnn.cn/tags/js/"/>
    
      <category term="javascript" scheme="https://mengnn.cn/tags/javascript/"/>
    
      <category term="常用方法" scheme="https://mengnn.cn/tags/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序音频播放带进度条显示以及音频切换功能</title>
    <link href="https://mengnn.cn/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E5%8A%9F%E8%83%BD/"/>
    <id>https://mengnn.cn/微信小程序实现音频播放功能/</id>
    <published>2025-02-18T08:43:29.506Z</published>
    <updated>2025-02-18T09:37:45.323Z</updated>
    
    <content type="html"><![CDATA[<p>开发微信小程序中遇到一个需求：需要能做到播放暂停音频，同时能够实时显示时间进度条（当然，进度条可拖拽），另外还要能够左右切换音频播放。</p><p>所以就想到了微信小程序原生的方法<code>wx.createInnerAudioContext()</code>，完成的同时外送一个可倍速的功能。当然如果你的音频有不同角色的链接，还可以实现男女切换等功能。效果图如下：</p><a id="more"></a><p><img src="https://cdn.mengxyz.com/blog/wxaudio.png" alt="案例图片"></p><p>具体实现方法及部分源代码如下：</p><h3 id="wxml部分代码"><a href="#wxml部分代码" class="headerlink" title="wxml部分代码"></a>wxml部分代码</h3><p>代码中引用的图片地址需要引用自己的，本案例只是做一个展示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声音列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"voiceBox"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"voice-list &#123;&#123;index == 0?'common-active':''&#125;&#125;"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;3&#125;&#125;"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">wx:key</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">bind:tap</span>=<span class="string">"getVoice"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"voice-number"</span>&gt;</span>0&#123;&#123;index+1&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"voice-text"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"voice-playBtn"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"img_off.png"</span> <span class="attr">mode</span>=<span class="string">"widthFix"</span> &gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"BtnBox"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 切换男女生按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"speakBtn"</span> <span class="attr">data-sex</span>=<span class="string">"men"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"icon_men.png"</span> <span class="attr">mode</span>=<span class="string">"widthFix"</span>  <span class="attr">bind:tap</span>=<span class="string">"changePerson"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"speedBtn"</span> <span class="attr">data-type</span>=<span class="string">"prev"</span> <span class="attr">bind:tap</span>=<span class="string">"changeVoice"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"icon_prev.png"</span> <span class="attr">mode</span>=<span class="string">"widthFix"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"playBtn"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 播放 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;isPlaying&#125;&#125;"</span> <span class="attr">src</span>=<span class="string">"icon_on.png"</span> <span class="attr">mode</span>=<span class="string">"widthFix"</span> <span class="attr">bind:tap</span>=<span class="string">"pauseAudio"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 暂停 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">wx:else</span> <span class="attr">src</span>=<span class="string">"icon_off.png"</span> <span class="attr">mode</span>=<span class="string">"widthFix"</span> <span class="attr">bind:tap</span>=<span class="string">"playAudio"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"speedBtn"</span> <span class="attr">data-type</span>=<span class="string">"next"</span>  <span class="attr">bind:tap</span>=<span class="string">"changeVoice"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"icon_next.png"</span> <span class="attr">mode</span>=<span class="string">"widthFix"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"speed"</span> <span class="attr">data-speed</span>=<span class="string">"&#123;&#123;doubleSpeed&#125;&#125;"</span> <span class="attr">bind:tap</span>=<span class="string">"setSpeed"</span>&gt;</span>&#123;&#123;doubleSpeed&#125;&#125;X<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="js部分代码"><a href="#js部分代码" class="headerlink" title="js部分代码"></a>js部分代码</h3><p>主要用到了创建音频实例（<code>wx.createInnerAudioContext()</code>）、播放（<code>InnerAudioContext.play()</code>）、暂停（<code>InnerAudioContext.pause()</code>）、监听音频播放进度更新（<code>InnerAudioContext.onTimeUpdate(function listener)</code>）、跳转到指定位置（<code>InnerAudioContext.seek(number position)</code>）、倍速播放（<code>playbackRate(number rate)</code>）等官方API。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    isPlaying: <span class="literal">false</span>, <span class="comment">// 是否正在播放</span></span><br><span class="line">    currentSlider:<span class="number">0</span>, <span class="comment">// 当前进度条值</span></span><br><span class="line">    currentSliderMax:<span class="number">0</span>, <span class="comment">// 进度条最大值</span></span><br><span class="line">    currentTime: <span class="number">0</span>, <span class="comment">// 当前播放进度</span></span><br><span class="line">    duration: <span class="number">120</span>, <span class="comment">// 音频总时长</span></span><br><span class="line">    doubleSpeed: <span class="number">1.0</span>, <span class="comment">// 播放倍速</span></span><br><span class="line">    audioUrl:<span class="string">'1.mp3'</span>,</span><br><span class="line">    isShowAudio:<span class="literal">false</span>, <span class="comment">// 是否显示音频</span></span><br><span class="line">    isShowAudioArrow:<span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面加载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onLoad(options) &#123;&#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面初次渲染完成</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onReady() &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *音频相关</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 初始化音频上下文</span></span><br><span class="line">  initializeAudio(url) &#123;</span><br><span class="line">    <span class="comment">// 每次调用音频方法之前判断当前页面是否有正在播放的实例</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.audioContext) &#123;</span><br><span class="line">      <span class="comment">// 停止当前播放</span></span><br><span class="line">      <span class="keyword">this</span>.audioContext.stop()</span><br><span class="line">      <span class="comment">// 销毁音频实例</span></span><br><span class="line">      <span class="keyword">this</span>.audioContext.destroy()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建音频实例（延迟到获取URL后创建）</span></span><br><span class="line">    <span class="keyword">this</span>.audioContext = wx.createInnerAudioContext()</span><br><span class="line">    <span class="comment">// 设置音频地址</span></span><br><span class="line">    <span class="keyword">this</span>.audioContext.src = url</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123; </span><br><span class="line">      audioUrl: url</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 绑定事件监听</span></span><br><span class="line">    <span class="comment">// 设置事件监听</span></span><br><span class="line">    <span class="keyword">this</span>.audioContext.onCanplay(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> durationTime = <span class="keyword">this</span>.audioContext.duration.toFixed(<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123; <span class="attr">duration</span>: <span class="keyword">this</span>.formatTime(durationTime) &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// 监听音频播放进度更新事件</span></span><br><span class="line">    <span class="keyword">this</span>.audioContext.onTimeUpdate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 实时设置音频播放进度及音频的总时长</span></span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        currentTime:<span class="keyword">this</span>.formatTime(<span class="keyword">this</span>.audioContext.currentTime),</span><br><span class="line">        currentSlider:<span class="keyword">this</span>.audioContext.currentTime,</span><br><span class="line">        currentSliderMax:<span class="keyword">this</span>.audioContext.duration,</span><br><span class="line">        duration:<span class="keyword">this</span>.formatTime(<span class="keyword">this</span>.audioContext.duration.toFixed(<span class="number">0</span>))</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// 监听音频自然播放至结束的事件</span></span><br><span class="line">    <span class="keyword">this</span>.audioContext.onEnded(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123; <span class="attr">isPlaying</span>: <span class="literal">false</span>, <span class="attr">currentTime</span>: <span class="number">0</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// 监听音频播放错误事件</span></span><br><span class="line">    <span class="keyword">this</span>.audioContext.onError(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.handleError(<span class="string">`播放失败（<span class="subst">$&#123;err.errCode&#125;</span>）`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 点击播放列表的方法，点击对应的音频并播放</span></span><br><span class="line">  getVoice()&#123;</span><br><span class="line">    <span class="comment">// 这里可以写异步请求，通过从后端获取音频地址</span></span><br><span class="line">    <span class="keyword">let</span> src = <span class="string">'1.mp3'</span></span><br><span class="line">    <span class="comment">// 获取到音频地址后调用音频初始化方法并判断是否播放</span></span><br><span class="line">    <span class="keyword">this</span>.initializeAudio(src)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.data.audioUrl) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.audioContext.play()</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      isShowAudio:<span class="literal">true</span>,</span><br><span class="line">      isPlaying:<span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 播放音频按钮</span></span><br><span class="line">  playAudio() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.data.audioUrl) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.audioContext.play();</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        isPlaying:<span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 暂停播放按钮</span></span><br><span class="line">  pauseAudio() &#123;</span><br><span class="line">    <span class="keyword">this</span>.audioContext.pause();</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        isPlaying:<span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 设置倍速</span></span><br><span class="line">  setSpeed(e) &#123;</span><br><span class="line">      <span class="comment">// 获取到你页面中存储的倍速数字</span></span><br><span class="line">      <span class="keyword">const</span> speed = <span class="built_in">Number</span>(e.currentTarget.dataset.speed.toFixed(<span class="number">1</span>))</span><br><span class="line">      <span class="keyword">if</span>(speed == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123; <span class="attr">doubleSpeed</span>: <span class="number">0.5</span> &#125;);</span><br><span class="line">        <span class="comment">// 设置音频倍速方法</span></span><br><span class="line">        <span class="keyword">this</span>.audioContext.playbackRate = <span class="number">0.5</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123; <span class="attr">doubleSpeed</span>: speed+<span class="number">0.5</span> &#125;);</span><br><span class="line">        <span class="keyword">this</span>.audioContext.playbackRate = speed+<span class="number">0.5</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 进度条拖动方法</span></span><br><span class="line">  seekAudio(e) &#123;</span><br><span class="line">    <span class="comment">// 获取进度条当前值</span></span><br><span class="line">    <span class="keyword">const</span> position = e.detail</span><br><span class="line">    <span class="comment">// 设置音频跳转到对应的时间</span></span><br><span class="line">    <span class="keyword">this</span>.audioContext.seek(position)</span><br><span class="line">    <span class="comment">// 同时赋值当前时间</span></span><br><span class="line">    <span class="keyword">this</span>.setData(&#123; </span><br><span class="line">      currentTime: <span class="keyword">this</span>.formatTime(position) </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">   <span class="comment">// 改变声源</span></span><br><span class="line">  changePerson()&#123;</span><br><span class="line">    <span class="keyword">let</span> src = <span class="string">'woman.mp3'</span></span><br><span class="line">    <span class="keyword">this</span>.initializeAudio(src)</span><br><span class="line">    <span class="keyword">this</span>.audioContext.play()</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      isShowAudio:<span class="literal">true</span>,</span><br><span class="line">      isPlaying:<span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 切换下一个方法</span></span><br><span class="line">  changeVoice(e)&#123;</span><br><span class="line">    <span class="comment">// 这里同样可以调用后台接口获取对应音频来播放</span></span><br><span class="line">    <span class="keyword">let</span> changeText = e.currentTarget.dataset.type</span><br><span class="line">    <span class="keyword">if</span>(changeText == <span class="string">'prev'</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> src = <span class="string">'2.mp3'</span></span><br><span class="line">      <span class="comment">// 获取到音频地址后调用我们的初始化方法</span></span><br><span class="line">      <span class="keyword">this</span>.initializeAudio(src)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> src = <span class="string">'3.mp3'</span></span><br><span class="line">      <span class="keyword">this</span>.initializeAudio(src)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 播放音频</span></span><br><span class="line">    <span class="keyword">this</span>.audioContext.play()</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      isShowAudio:<span class="literal">true</span>,</span><br><span class="line">      isPlaying:<span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 时间格式化（秒 -&gt; 分:秒）</span></span><br><span class="line">  formatTime(seconds) &#123;</span><br><span class="line">    <span class="keyword">const</span> min = <span class="built_in">Math</span>.floor(seconds / <span class="number">60</span>)</span><br><span class="line">    <span class="keyword">const</span> sec = <span class="built_in">Math</span>.floor(seconds % <span class="number">60</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;min&#125;</span>:<span class="subst">$&#123;sec.toString().padStart(<span class="number">2</span>, <span class="string">'0'</span>)&#125;</span>`</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面卸载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onUnload() &#123;</span><br><span class="line">    <span class="comment">// 记得每次页面卸载后，销毁音频实例</span></span><br><span class="line">    <span class="comment">// 当然你也可以根据自己的需求销毁实例</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.audioContext) &#123;</span><br><span class="line">        <span class="keyword">this</span>.audioContext.stop()</span><br><span class="line">        <span class="keyword">this</span>.audioContext.destroy()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>记得每次切换新的音频时，要销毁原有的音频实例，然后重新创建新的实例。每次页面卸载记得要销毁页面中的音频实例。</p><p>以上就是一个简单的小程序音频播放案例，除了样式外，功能基本能满足日常需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发微信小程序中遇到一个需求：需要能做到播放暂停音频，同时能够实时显示时间进度条（当然，进度条可拖拽），另外还要能够左右切换音频播放。&lt;/p&gt;
&lt;p&gt;所以就想到了微信小程序原生的方法&lt;code&gt;wx.createInnerAudioContext()&lt;/code&gt;，完成的同时外送一个可倍速的功能。当然如果你的音频有不同角色的链接，还可以实现男女切换等功能。效果图如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="微信小程序" scheme="https://mengnn.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="进度条" scheme="https://mengnn.cn/tags/%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    
      <category term="音频切换" scheme="https://mengnn.cn/tags/%E9%9F%B3%E9%A2%91%E5%88%87%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>实现水印的几种常用方式</title>
    <link href="https://mengnn.cn/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%8D%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F/"/>
    <id>https://mengnn.cn/前端实现水印的几种常见方式/</id>
    <published>2025-02-14T09:18:28.330Z</published>
    <updated>2025-02-14T09:29:32.506Z</updated>
    
    <content type="html"><![CDATA[<p>水印通常用于保护版权、增强品牌识别度或提供额外的信息。<br>通过在前端实现水印，可以有效地保护内容的版权，增强品牌识别度，提供额外的信息，同时满足法律合规和安全防护的需求。</p><h3 id="1-通过css背景图"><a href="#1-通过css背景图" class="headerlink" title="1.通过css背景图"></a>1.通过css背景图</h3><p>可以通过CSS的 <code>background-image</code>属性，将水印图片设置为页面的背景图。这种方式简单易用，适用于不需要动态生成水印的静态页面。</p><a id="more"></a><p><strong>优点：</strong></p><ul><li>通过 CSS 的 <code>background-image</code> 属性即可实现，代码简洁，易于理解和维护。</li><li>几乎所有现代浏览器都支持 CSS 背景图，无需额外的 JavaScript 支持。</li><li>背景图的加载和渲染性能较好，不会对页面性能造成显著影响。</li></ul><p><strong>缺点：</strong></p><ul><li>对于复杂布局或动态内容，CSS 背景图的控制力较弱。</li><li>水印容易被移除,用户可以通过修改 CSS 或者使用开发者工具轻松移除背景图水印。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.watermark</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'watermark.png'</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>: repeat;</span><br><span class="line">  <span class="attribute">background-position</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-通过canvas"><a href="#2-通过canvas" class="headerlink" title="2.通过canvas"></a>2.通过canvas</h3><p>利用HTML5的 <code>Canvas API</code>，可以在页面上动态绘制水印。这种方式灵活性高，可以自定义水印的内容、样式和位置,适用于需要绘制复杂图形或文字的水印以及一些对水印安全性要求较高的场景。</p><p><strong>优点：</strong></p><ul><li>动态生成水印：可以使用 JavaScript 动态生成水印，支持自定义水印内容、位置、样式等。</li><li>水印嵌入图像：水印可以嵌入到图像中，不易被移除，安全性较高。</li><li>灵活性高：可以绘制复杂的图形和文字，适合各种复杂的水印需求。</li></ul><p><strong>缺点：</strong></p><ul><li>需要浏览器支持 JavaScript，否则无法生成水印。</li><li>在性能较差的设备上，绘制复杂水印可能会有一定的性能开销。</li><li>虽然大多数现代浏览器支持 Canvas，但一些旧版本浏览器可能不支持。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>实现水印的几种常用方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line">         canvas &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            z-index: 1;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">            z-index: 2;</span><br><span class="line">            padding: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is some content overlayed on top of the canvas.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 创建canvas画布</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 获取画布上下文</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 设置画布大小</span></span></span><br><span class="line"><span class="javascript">        canvas.width = <span class="built_in">window</span>.innerWidth;</span></span><br><span class="line"><span class="javascript">        canvas.height = <span class="built_in">window</span>.innerHeight;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 设置文本字体大小</span></span></span><br><span class="line"><span class="javascript">        ctx.font = <span class="string">'48px Arial'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 设置画笔颜色及透明度</span></span></span><br><span class="line"><span class="javascript">        ctx.fillStyle = <span class="string">'rgba(200, 200, 200, 0.5)'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 旋转画布</span></span></span><br><span class="line"><span class="javascript">        ctx.rotate(-<span class="built_in">Math</span>.PI / <span class="number">4</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 绘制文本，且设置文本x,y坐标</span></span></span><br><span class="line"><span class="javascript">        ctx.fillText(<span class="string">'Watermark Text'</span>, <span class="number">50</span>, <span class="number">500</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 将canvas添加到body中</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(canvas);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-通过SVG"><a href="#3-通过SVG" class="headerlink" title="3.通过SVG"></a>3.通过SVG</h3><p>SVG（Scalable Vector Graphics）是一种用于描述二维矢量图形的XML标记语言，它使用矢量图形而不是位图来表示图像。SVG可以提供比Canvas更好的兼容性，并且支持更多的图形元素，如文本、路径、图像等。通过在页面上插入SVG元素，可以实现水印效果。</p><p><strong>优点：</strong></p><ul><li>SVG 是矢量图形格式，水印可以缩放而不会失真，适合响应式布局。</li><li>灵活性高,可以使用 SVG 的各种元素和属性，绘制复杂的图形和文字。</li><li>兼容性较好,大多数现代浏览器都支持 SVG，但需要注意一些旧版本浏览器的兼容性问题。</li></ul><p><strong>缺点：</strong></p><ul><li>水印容易被移除,用户可以通过 DOM 操作移除 SVG 水印。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"200px"</span> <span class="attr">height</span>=<span class="string">"200px"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">style</span>=<span class="string">"position: absolute;top: 0;left: 0;right:0;bottom:0;margin:auto;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">"10px"</span> <span class="attr">y</span>=<span class="string">"100px"</span> <span class="attr">font-size</span>=<span class="string">"18px"</span> <span class="attr">fill</span>=<span class="string">"rgba(18, 18, 18, 0.2)"</span> <span class="attr">transform</span>=<span class="string">"rotate(-20 10,20)"</span>&gt;</span></span><br><span class="line">        Watermark Text</span><br><span class="line">    <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-使用第三方库"><a href="#4-使用第三方库" class="headerlink" title="4.使用第三方库"></a>4.使用第三方库</h3><p>可以使用一些第三方库，如 <code>watermark-js-plus</code>，基于 canvas 画布的水印库，支持文本、多行文本、图片、富文本和暗水印;支持监听 DOM 改动行为，可防止水印被手动删除;提供丰富的配置项和完全类型化的 API。<br>可以通过 <code>npm</code> 安装的方式或者以 <code>cdn</code> 的方式引入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>实现水印的几种常用方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/watermark-js-plus/dist/index.iife.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> watermark = <span class="keyword">new</span> WatermarkPlus.Watermark(&#123;</span></span><br><span class="line"><span class="javascript">        content: <span class="string">'hello my watermark'</span>,</span></span><br><span class="line">            width: 200,</span><br><span class="line">            height: 200 ,</span><br><span class="line"><span class="javascript">            rotate:<span class="number">45</span>, <span class="comment">// 水印旋转角度</span></span></span><br><span class="line">        &#125;)</span><br><span class="line">        watermark.create();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;水印通常用于保护版权、增强品牌识别度或提供额外的信息。&lt;br&gt;通过在前端实现水印，可以有效地保护内容的版权，增强品牌识别度，提供额外的信息，同时满足法律合规和安全防护的需求。&lt;/p&gt;
&lt;h3 id=&quot;1-通过css背景图&quot;&gt;&lt;a href=&quot;#1-通过css背景图&quot; class=&quot;headerlink&quot; title=&quot;1.通过css背景图&quot;&gt;&lt;/a&gt;1.通过css背景图&lt;/h3&gt;&lt;p&gt;可以通过CSS的 &lt;code&gt;background-image&lt;/code&gt;属性，将水印图片设置为页面的背景图。这种方式简单易用，适用于不需要动态生成水印的静态页面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="水印" scheme="https://mengnn.cn/tags/%E6%B0%B4%E5%8D%B0/"/>
    
      <category term="canvas" scheme="https://mengnn.cn/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>Vue3+Element-plus实现自定义图片上传</title>
    <link href="https://mengnn.cn/Vue3+Element-plus%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    <id>https://mengnn.cn/Vue3+Element-plus实现自定义图片上传/</id>
    <published>2025-01-17T06:28:23.551Z</published>
    <updated>2025-01-17T06:43:43.745Z</updated>
    
    <content type="html"><![CDATA[<p>默认已经安装好各种依赖，主要用到<code>element-plus</code>、<code>axios</code>。</p><p>通过<code>Upload</code>组件的<code>http-request</code>属性实现自定义图片上传请求功能。</p><a id="more"></a><p>代码实现：</p><p>通过自定义的<code>uploadRequest</code>方法，来实现图片上传和回显。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;el-form :model=&quot;editForm&quot;&gt;</span><br><span class="line">        &lt;el-form-item label=&quot;图片上传：&quot;&gt;</span><br><span class="line">            &lt;img :src=&quot;editForm.imageLink&quot; class=&quot;imgBox&quot;&gt;</span><br><span class="line">            &lt;el-upload</span><br><span class="line">                       :http-request=&quot;uploadRequest&quot;</span><br><span class="line">                       :limit=&quot;1&quot;</span><br><span class="line">                       v-model:file-list=&quot;fileList&quot;</span><br><span class="line">                       &gt;</span><br><span class="line">                &lt;el-button type=&quot;primary&quot;&gt;上传图片&lt;/el-button&gt;</span><br><span class="line">            &lt;/el-upload&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">    &lt;/el-form&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">    import axios from &apos;axios&apos;</span><br><span class="line">    import &#123;onMounted, reactive,ref&#125; from &apos;vue&apos;</span><br><span class="line">    //定义一个响应式数组用来接收图片</span><br><span class="line">    const fileList = ref([])</span><br><span class="line">    const editForm = reactive(&#123;</span><br><span class="line">        imageLink: &apos;&apos;,</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    // 自定义图片方法</span><br><span class="line">    function uploadRequest(options)&#123;</span><br><span class="line">        const &#123;file&#125; = options;</span><br><span class="line">        let applyFile = new FormData();</span><br><span class="line">        applyFile.append(&apos;applyFile&apos;, file);</span><br><span class="line">        </span><br><span class="line">        axios.post(&apos;http://localhost/api&apos;, applyFile,&#123;</span><br><span class="line">        headers: &#123;</span><br><span class="line">            &quot;Content-Type&quot;: &quot;multipart/form-data&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;).then(res=&gt;&#123;</span><br><span class="line">            editForm.imageLink = res.data.fileURL</span><br><span class="line">            // 上传成功获取回显值后要置空，否则二次上传会有问题</span><br><span class="line">            normalFileList.value = []</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.imgBox &#123;</span><br><span class="line">    width: 30px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;默认已经安装好各种依赖，主要用到&lt;code&gt;element-plus&lt;/code&gt;、&lt;code&gt;axios&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;Upload&lt;/code&gt;组件的&lt;code&gt;http-request&lt;/code&gt;属性实现自定义图片上传请求功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue3" scheme="https://mengnn.cn/tags/Vue3/"/>
    
      <category term="element-plus" scheme="https://mengnn.cn/tags/element-plus/"/>
    
      <category term="图片上传" scheme="https://mengnn.cn/tags/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>数组常用方法合集，以及数组循环方法对比</title>
    <link href="https://mengnn.cn/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/"/>
    <id>https://mengnn.cn/数组常用方法合集/</id>
    <published>2024-12-26T02:12:29.297Z</published>
    <updated>2024-12-26T02:21:20.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-for和forEach"><a href="#01-for和forEach" class="headerlink" title="01-for和forEach"></a>01-for和forEach</h2><ul><li>for循环是最常规最通用的一种循环遍历方法；</li><li>forEach方法是一个高阶函数，会引入额外的函数调用开销，forEach会改变原数组；</li></ul><h3 id="1-性能上的比较"><a href="#1-性能上的比较" class="headerlink" title="1.性能上的比较"></a>1.性能上的比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for&gt;forEach</span><br></pre></td></tr></table></figure><ul><li>for循环直接操作索引，没有额外的函数调用和上下文，所以性能是最快的</li><li>for可以使用break终止，forEach不支持跳出循环</li></ul><p>尝试分别用<code>for</code>和<code>forEach</code>循环遍历数量级比较大的数组，<code>for</code>循环用时<code>小于``forEach</code>的执行时间。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个数量级比较大的数组</span><br><span class="line">let arrs = [...Array(9999999).keys()];</span><br><span class="line">let total = 0;</span><br><span class="line">let startTime = Date.now();</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; arrs.length; i++) total += i;</span><br><span class="line">let endTime = Date.now();</span><br><span class="line">let countTime = endTime - startTime;</span><br><span class="line">console.log(&apos;计数----&gt;&apos; + total); //计数----&gt;49999985000001</span><br><span class="line">console.log(&apos;消耗时间----&gt;&apos; + countTime); //消耗时间----&gt;127</span><br><span class="line">// 定义一个数量级比较大的数组</span><br><span class="line">let arrs = [...Array(9999999).keys()];</span><br><span class="line">let total = 0;</span><br><span class="line">let startTime = Date.now();</span><br><span class="line">    </span><br><span class="line">arrs.forEach((item) =&gt; (total += item));</span><br><span class="line">  </span><br><span class="line">let endTime = Date.now();</span><br><span class="line">let countTime = endTime - startTime;</span><br><span class="line">console.log(&apos;计数----&gt;&apos; + total); //计数----&gt;49999985000001</span><br><span class="line">console.log(&apos;消耗时间----&gt;&apos; + countTime); //消耗时间----&gt;267</span><br></pre></td></tr></table></figure><h3 id="2-异步同步化的支持度"><a href="#2-异步同步化的支持度" class="headerlink" title="2.异步同步化的支持度"></a>2.异步同步化的支持度</h3><p><code>forEach</code>函数内，不支持await异步等待。</p><p>如下案例，使用<code>forEach</code>模拟异步请求时，获取结果为空数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [1, 2, 3];</span><br><span class="line">let datas = [];</span><br><span class="line">function fetchData() &#123;</span><br><span class="line">arrs.forEach(async (item) =&gt; &#123;</span><br><span class="line">const &#123; data &#125; = await uni.request(&#123;</span><br><span class="line">url: &apos;http://jsonplaceholder.typicode.com/posts/&apos; + item</span><br><span class="line">&#125;);</span><br><span class="line">datas.push(data);</span><br><span class="line">&#125;);</span><br><span class="line">  console.log(datas); // []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetchData();</span><br></pre></td></tr></table></figure><p>该用<code>for</code>循环后，可以获取对应的三条数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [1, 2, 3];</span><br><span class="line">let datas = [];</span><br><span class="line">async function fetchData() &#123;</span><br><span class="line">for (let i = 0; i &lt; arrs.length; i++) &#123;</span><br><span class="line">const &#123; data &#125; = await uni.request(&#123;</span><br><span class="line">url: &apos;http://jsonplaceholder.typicode.com/posts/&apos; + arrs[i]</span><br><span class="line">&#125;);</span><br><span class="line">datas.push(data);</span><br><span class="line">&#125;</span><br><span class="line">console.log(datas); // [&#123;...&#125;,&#123;...&#125;,&#123;...&#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetchData();</span><br></pre></td></tr></table></figure><h2 id="02-map方法"><a href="#02-map方法" class="headerlink" title="02-map方法"></a>02-map方法</h2><p><code>map()</code> 方法是数组原型的一个函数，数组遍历不破坏原数组，将会创建一个新数组，按照原始数组元素顺序依次执行给定的函数。</p><p><code>map()</code>方法非常适合用于处理数组中的每个元素并生成新的数组。</p><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h3><ul><li><code>map(callbackFn)</code></li><li><code>map(callbackFn,thisArg)</code></li></ul><p>1.参数<code>callbackFn</code></p><p>为数组中的每个元素执行的函数。它的返回值作为一个元素被添加为新数组中。该函数被调用时将传入以下参数：</p><p><code>element</code>：数组中当前正在处理的元素。</p><p><code>index</code>：正在处理的元素在数组中的索引。</p><p><code>array</code>：调用了 <code>map()</code> 的数组本身。</p><p>2.参数<code>thisArg</code>（可选）</p><p>执行 <code>callbackFn</code> 时用作 <code>this</code> 的值。</p><h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h3><h4 id="1-将数组中的每个元素x2获取新数组"><a href="#1-将数组中的每个元素x2获取新数组" class="headerlink" title="1.将数组中的每个元素x2获取新数组"></a>1.将数组中的每个元素<code>x2</code>获取新数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">let newArrs = arrs.map((item) =&gt; item * 2);</span><br><span class="line">console.log(newArrs); // [2, 4, 6, 8, 10]</span><br><span class="line">console.log(arrs); // [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><h4 id="2-获取数组中的名字，并保存到新数组中"><a href="#2-获取数组中的名字，并保存到新数组中" class="headerlink" title="2.获取数组中的名字，并保存到新数组中"></a>2.获取数组中的名字，并保存到新数组中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;电脑&apos;,</span><br><span class="line">price: 12999</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;手机&apos;,</span><br><span class="line">price: 8499</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;平板&apos;,</span><br><span class="line">price: 5299</span><br><span class="line">&#125;</span><br><span class="line">];</span><br><span class="line">let newArrs = arrs.map((item) =&gt; &#123;</span><br><span class="line">return item.name;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(newArrs); // [&apos;电脑&apos;, &apos;手机&apos;, &apos;平板&apos;]</span><br></pre></td></tr></table></figure><h4 id="3-修改数组中的价格，并新增number属性"><a href="#3-修改数组中的价格，并新增number属性" class="headerlink" title="3.修改数组中的价格，并新增number属性"></a>3.修改数组中的价格，并新增number属性</h4><p>写入的price属性，如果原来有，会覆盖原有的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;电脑&apos;,</span><br><span class="line">price: 12999</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;手机&apos;,</span><br><span class="line">price: 8499</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;平板&apos;,</span><br><span class="line">price: 5299</span><br><span class="line">&#125;</span><br><span class="line">];</span><br><span class="line">let newArrs = arrs.map((item) =&gt; &#123;</span><br><span class="line">return &#123;</span><br><span class="line">...item,</span><br><span class="line">price: item.price + 100,</span><br><span class="line">number: 1000</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(newArrs);</span><br></pre></td></tr></table></figure><h4 id="4-修改数组中的属性名，并可通过解构的写法"><a href="#4-修改数组中的属性名，并可通过解构的写法" class="headerlink" title="4.修改数组中的属性名，并可通过解构的写法"></a>4.修改数组中的属性名，并可通过解构的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [</span><br><span class="line">&#123;</span><br><span class="line">key: 1,</span><br><span class="line">content: &apos;电脑&apos;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">key: 2,</span><br><span class="line">content: &apos;手机&apos;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">key: 3,</span><br><span class="line">content: &apos;平板&apos;</span><br><span class="line">&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let newArrs = arrs.map((item) =&gt; &#123;</span><br><span class="line">return &#123;</span><br><span class="line">id: item.key,</span><br><span class="line">text: item.content</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(newArrs);</span><br><span class="line">// [</span><br><span class="line">// &#123;</span><br><span class="line">// key: 1,</span><br><span class="line">// content: &apos;电脑&apos;</span><br><span class="line">// &#125;,</span><br><span class="line">// &#123;</span><br><span class="line">// key: 2,</span><br><span class="line">// content: &apos;手机&apos;</span><br><span class="line">// &#125;,</span><br><span class="line">// &#123;</span><br><span class="line">// key: 3,</span><br><span class="line">// content: &apos;平板&apos;</span><br><span class="line">// &#125;</span><br><span class="line">// ];</span><br></pre></td></tr></table></figure><p>通过解构的方式，把item解构成对应的值更直观</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [</span><br><span class="line">&#123;</span><br><span class="line">key: 1,</span><br><span class="line">content: &apos;电脑&apos;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">key: 2,</span><br><span class="line">content: &apos;手机&apos;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">key: 3,</span><br><span class="line">content: &apos;平板&apos;</span><br><span class="line">&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let newArrs = arrs.map((&#123; key, content &#125;) =&gt; &#123;</span><br><span class="line">return &#123;</span><br><span class="line">id: key,</span><br><span class="line">text: content</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(newArrs);</span><br></pre></td></tr></table></figure><h4 id="5-异步请求测试"><a href="#5-异步请求测试" class="headerlink" title="5.异步请求测试"></a>5.异步请求测试</h4><p>network请求的状况，会同时发送请求，会节省很多的时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [1, 2, 3];</span><br><span class="line">let datas = arrs.map(async (item) =&gt; &#123;</span><br><span class="line">let res = await uni.request(&#123;</span><br><span class="line">url: &apos;http://jsonplaceholder.typicode.com/posts/&apos; + item</span><br><span class="line">&#125;);</span><br><span class="line">return res;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(datas); // [Promise, Promise, Promise]</span><br><span class="line">Promise.all(datas).then((res) =&gt; &#123;</span><br><span class="line">console.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="03-filter方法"><a href="#03-filter方法" class="headerlink" title="03-filter方法"></a>03-filter方法</h2><p><code>filter()</code>过滤方法，会对原数组中的每个元素应用指定的函数，并返回一个新数组，其中包含符合条件的元素。原数组不会受到影响。</p><h3 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1.语法"></a>1.语法</h3><p>和<code>map</code>语法相似</p><ul><li><code>fliter(callbackFn)</code></li><li><code>filter(callbackFn,thisArg)</code></li></ul><p>1.参数<code>callbackFn</code><br>为数组中的每个元素执行的函数。它的返回值作为一个元素被添加为新数组中。该函数被调用时将传入以下参数：<br><code>element</code>：数组中当前正在处理的元素。<br><code>index</code>：正在处理的元素在数组中的索引。<br><code>array</code>：调用了 <code>filter()</code> 的数组本身。</p><p>2.参数<code>thisArg</code>（可选）<br>执行 <code>callbackFn</code> 时用作 this 的值。</p><h3 id="2-用法-1"><a href="#2-用法-1" class="headerlink" title="2.用法"></a>2.用法</h3><p>1.在<code>filter</code>回调函数中，满足true即可被处理到新函数中，false不做处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [1, 5, 2, 8, 10];</span><br><span class="line">let newArrs = arrs.filter((item) =&gt; &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(newArrs); // true [1, 5, 2, 8, 10]   false []</span><br></pre></td></tr></table></figure><p>2.返回一个年龄大于30的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;张三&apos;,</span><br><span class="line">age: 18</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;李四&apos;,</span><br><span class="line">age: 28</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;王二&apos;,</span><br><span class="line">age: 30</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;赵五&apos;,</span><br><span class="line">age: 38</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;孙六&apos;,</span><br><span class="line">age: 32</span><br><span class="line">&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let newArrs = arrs.filter((item) =&gt; &#123;</span><br><span class="line">return item.age &gt; 30;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(newArrs);</span><br><span class="line">// [</span><br><span class="line">// &#123;</span><br><span class="line">// name: &apos;赵五&apos;,</span><br><span class="line">// age: 38</span><br><span class="line">// &#125;,</span><br><span class="line">// &#123;</span><br><span class="line">// name: &apos;孙六&apos;,</span><br><span class="line">// age: 32</span><br><span class="line">// &#125;</span><br><span class="line">// ];</span><br></pre></td></tr></table></figure><h3 id="3-配合indexOf进行数组去重"><a href="#3-配合indexOf进行数组去重" class="headerlink" title="3.配合indexOf进行数组去重"></a>3.配合indexOf进行数组去重</h3><p>首先，<code>indexOf()</code>方法返回的是查找的第一个符合的元素的下标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [1, 5, 2, 8, 2, 5, 9];</span><br><span class="line">console.log(arrs.indexOf(5)); // 找到第一个符合的元素5，返回索引值 1</span><br></pre></td></tr></table></figure><p>然后，配合<code>filter()</code>方法实现数组去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [1, 5, 2, 8, 2, 5, 9];</span><br><span class="line">let newArrs = arrs.filter((item, index, self) =&gt; &#123;</span><br><span class="line">return self.indexOf(item) === index;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(newArrs); // [1, 5, 2, 8, 9]</span><br></pre></td></tr></table></figure><h3 id="4-filter和map方法实现链式调用"><a href="#4-filter和map方法实现链式调用" class="headerlink" title="4.filter和map方法实现链式调用"></a>4.filter和map方法实现链式调用</h3><p>先用<code>filter()</code>方法处理数据，然后在调用<code>map()</code>方法处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;张三&apos;,</span><br><span class="line">age: 18</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;李四&apos;,</span><br><span class="line">age: 28</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;王二&apos;,</span><br><span class="line">age: 30</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;赵五&apos;,</span><br><span class="line">age: 38</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;孙六&apos;,</span><br><span class="line">age: 32</span><br><span class="line">&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let newArrs = arrs</span><br><span class="line">.filter((item) =&gt; &#123;</span><br><span class="line">return item.age &gt; 30;</span><br><span class="line">&#125;)</span><br><span class="line">.map((item) =&gt; &#123;</span><br><span class="line">return &#123;</span><br><span class="line">...item,</span><br><span class="line">des: &apos;大龄程序员&apos;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(newArrs);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/2112612/1734341546147-11bfe88f-3a8e-4aa9-8b07-11c327a12e82.png" alt="img"></p><h2 id="04-reduce方法"><a href="#04-reduce方法" class="headerlink" title="04-reduce方法"></a>04-reduce方法</h2><p><code>**reduce()**</code> 方法对数组中的每个元素按序执行一个提供的 <strong>reducer</strong> 函数，每一次运行 <strong>reducer</strong> 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。</p><h3 id="1-语法-2"><a href="#1-语法-2" class="headerlink" title="1.语法"></a>1.语法</h3><ul><li><code>reduce(callbackFn)</code></li><li><code>reduce(callbackFn,initialValue)</code></li></ul><p>1.参数<code>callbackFn</code></p><p>为数组中每个元素执行的函数。其返回值将作为下一次调用 <code>callbackFn</code> 时的 <code>accumulator</code> 参数。对于最后一次调用，返回值将作为 <code>reduce()</code> 的返回值。该函数被调用时将传入以下参数：</p><ul><li><code>prev</code>（必填），上一次调用 callbackFn 的结果。</li><li><code>current</code>（必填），当前元素的值。</li><li><code>index</code>（可选），current 在数组中的索引位置。</li><li><code>array</code>（可选），调用了reduce() 的数组本身。</li></ul><p>2.参数<code>initialValue</code></p><p>第一次调用回调时初始化 <code>accumulator</code> 的值。如果指定了 <code>initialValue</code>，则 <code>callbackFn</code> 从数组中的第一个值作为 <code>currentValue</code> 开始执行。如果没有指定 <code>initialValue</code>，则 <code>accumulator</code> 初始化为数组中的第一个值，并且 <code>callbackFn</code> 从数组中的第二个值作为 <code>currentValue</code> 开始执行。在这种情况下，如果数组为空（没有第一个值可以作为 <code>accumulator</code> 返回），则会抛出错误。</p><h3 id="2-用法-2"><a href="#2-用法-2" class="headerlink" title="2.用法"></a>2.用法</h3><p>1.简单的求和或求积</p><p>如果没有定义初始值，那么prev就默认数组第一个值，current为第二个值，切循环执行了四次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [1, 2, 3, 4, 5];</span><br><span class="line">arrs.reduce((prev, current, index) =&gt; &#123;</span><br><span class="line">console.log(prev, current, index);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/2112612/1734342553046-afb9ac04-5890-45f2-a114-5a4eac031e18.png" alt="img"></p><p>如果默认传入初始值，则循环从第一个开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [1, 2, 3, 4, 5];</span><br><span class="line">let result = arrs.reduce((prev, current, index) =&gt; &#123;</span><br><span class="line">return prev + current;</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(result); // 15</span><br></pre></td></tr></table></figure><p>稍微复杂点的求和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 对年龄求和</span><br><span class="line">let arrs = [</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;张三&apos;,</span><br><span class="line">age: 18</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;李四&apos;,</span><br><span class="line">age: 28</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;王二&apos;,</span><br><span class="line">age: 30</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;赵五&apos;,</span><br><span class="line">age: 38</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name: &apos;孙六&apos;,</span><br><span class="line">age: 32</span><br><span class="line">&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let result = arrs.reduce((prev, current, index) =&gt; &#123;</span><br><span class="line">return prev + current.age;</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(result); // 146</span><br></pre></td></tr></table></figure><p>2.求最大值或最小值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [18, 25, 10, 58, 26];</span><br><span class="line">let result = arrs.reduce((prev, current) =&gt; &#123;</span><br><span class="line">return Math.max(prev, current);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(result);// 58</span><br></pre></td></tr></table></figure><h2 id="05-every和some方法"><a href="#05-every和some方法" class="headerlink" title="05-every和some方法"></a>05-every和some方法</h2><p><code>every()</code>方法只有所有数据都满足条件才会返回<code>true</code>，而<code>some()</code>方法只有有一个数据满足条件就返回<code>true</code>.</p><h3 id="一-every方法"><a href="#一-every方法" class="headerlink" title="一.every方法"></a>一.every方法</h3><p><code>**every()**</code> 方法测试一个数组内的所有元素是否都能通过指定函数的测试。它返回一个布尔值。</p><h4 id="1-语法-3"><a href="#1-语法-3" class="headerlink" title="1.语法"></a>1.语法</h4><ul><li><code>every(callbackFn)</code></li><li><code>every(callbackFn,thisArg)</code></li></ul><p>1.参数<code>callbackFn</code></p><ul><li><code>element</code> ：数组中当前正在处理的元素。</li><li><code>index</code>： 正在处理的元素在数组中的索引。</li><li><code>array</code> ：调用了 every() 的数组本身。</li></ul><p>2.参数<code>thisArg</code></p><ul><li>执行<code>callbackFn</code> 时用作 this 的值。</li></ul><h4 id="2-用法-3"><a href="#2-用法-3" class="headerlink" title="2.用法"></a>2.用法</h4><p>通过判断数组中的数值是否大于10，只有当所有的数值都大于10的时候，参会返回<code>true</code>，否则返回<code>false</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [15, 10, 5, 100];</span><br><span class="line">let result = arrs.every((item) =&gt; item &gt; 10);</span><br><span class="line">console.log(result); // false</span><br></pre></td></tr></table></figure><h3 id="二-some方法"><a href="#二-some方法" class="headerlink" title="二.some方法"></a>二.some方法</h3><p><code>**some()**</code> 方法测试数组中是否至少有一个元素通过了由提供的函数实现的测试。如果在数组中找到一个元素使得提供的函数返回 true，则返回 true；否则返回 false。它不会修改数组。</p><p>语法和用法同上</p><p>只要有一个条件满足，就直接返回<code>true</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arrs = [15, 10, 5, 100];</span><br><span class="line">let result = arrs.some((item) =&gt; item &gt; 10);</span><br><span class="line">console.log(result); // true</span><br></pre></td></tr></table></figure><h2 id="06-includes包含方法"><a href="#06-includes包含方法" class="headerlink" title="06-includes包含方法"></a>06-includes包含方法</h2><p><code>**includes()**</code> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 <code>true</code>，否则返回 <code>false</code>。</p><h3 id="1-语法-4"><a href="#1-语法-4" class="headerlink" title="1.语法"></a>1.语法</h3><ul><li><code>includes(searchElement)</code></li><li><code>includes(searchElement,fromIndex)</code></li></ul><p>1.<code>searchElement</code> 参数</p><p>需要查找的值。</p><p>2.<code>fromIndex</code>参数（可选）</p><p>几乎不用。开始搜索的索引（从零开始），<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number#整数转换" target="_blank" rel="noopener">会转换为整数</a>。</p><h3 id="2-用法-4"><a href="#2-用法-4" class="headerlink" title="2.用法"></a>2.用法</h3><p>判断某个数字是否包含在数组内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arrs = [1, 2, 3, 4, 5];</span><br><span class="line">console.log(arrs.includes(5)); // true</span><br><span class="line">console.log(arrs.includes(8)); // false</span><br></pre></td></tr></table></figure><p>只能判断某个值，像下面的情况为<code>false</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5, [6, 7]];</span><br><span class="line">console.log(arrs.includes(5)); // true</span><br><span class="line">console.log(arrs.includes([6, 7])); // false</span><br></pre></td></tr></table></figure><p>配合<code>every</code>方法，实现判断某个数组是否包含在另一个数组中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const arrs = [18, 2, 9, 6, 8];</span><br><span class="line">const arrs2 = [18, 2, 9];</span><br><span class="line">const arrs3 = [18, 2, 20];</span><br><span class="line">let isIncludes = arrs2.every((item) =&gt; &#123;</span><br><span class="line">return arrs.includes(item);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(isIncludes); // true</span><br><span class="line"></span><br><span class="line">let isIncludes2 = arrs3.every((item) =&gt; arrs.includes(item));</span><br><span class="line">console.log(isIncludes2); // false</span><br></pre></td></tr></table></figure><h2 id="07-其他常用方法"><a href="#07-其他常用方法" class="headerlink" title="07-其他常用方法"></a>07-其他常用方法</h2><h3 id="1-concat"><a href="#1-concat" class="headerlink" title="1.concat"></a>1.concat</h3><p><code>**concat()**</code> 方法用于合并两个或多个数组。此方法<strong>不会改变原数组</strong>，而是返回一个新数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [1, 2, 3];</span><br><span class="line">let arr2 = [4, 5, 6, 7];</span><br><span class="line">console.log(arr1.concat(arr2)); // [1, 2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure><h3 id="2-find"><a href="#2-find" class="headerlink" title="2.find"></a>2.find</h3><p><code>**find()**</code> 方法<strong>返回数组中满足提供的测试函数的第一个元素的值</strong>。否则返回 undefined 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [10, 20, 30, 40];</span><br><span class="line">let result = arr1.find((item) =&gt; &#123;</span><br><span class="line">return item &gt; 20;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // 30</span><br></pre></td></tr></table></figure><h3 id="3-findIndex"><a href="#3-findIndex" class="headerlink" title="3.findIndex"></a>3.findIndex</h3><p><code>**findIndex(**</code><strong>)</strong> 方法返回数组中满足提供的测试函数的<strong>第一个元素的索引</strong>。否则返回-1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [10, 20, 30, 40];</span><br><span class="line">let result = arr1.findIndex((item) =&gt; &#123;</span><br><span class="line">return item &gt; 20;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result); // 2</span><br></pre></td></tr></table></figure><h3 id="4-indexOf"><a href="#4-indexOf" class="headerlink" title="4.indexOf"></a>4.indexOf</h3><p><code>**indexOf()**</code> 方法返回在数组中可以<strong>找到一个给定元素的**</strong>第一个<strong>**索引</strong>，如果<strong>不存在，则返回-1</strong>。 （通常用它判断数组中有没有这个元素）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [10, 20, 30, 40, 20];</span><br><span class="line">let result = arr1.indexOf(20);</span><br><span class="line">let result2 = arr1.indexOf(120);</span><br><span class="line">console.log(result); // 返回索引值：1</span><br><span class="line">console.log(result2); // -1</span><br></pre></td></tr></table></figure><h3 id="5-join"><a href="#5-join" class="headerlink" title="5.join"></a>5.join</h3><p><code>**join()**</code>方法将一个数组（或一个类数组对象）的所有元素<strong>连接成一个字符串并返回这个字符串</strong>。 如果数组只有一个项目，那么将返回该项目而不使用分隔符。</p><p>可自定义分隔符，默认为<code>,</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [10, 20, 30, 40, 20];</span><br><span class="line">let result = arr1.join();</span><br><span class="line">console.log(result); // 10,20,30,40,20</span><br><span class="line">let result2 = arr1.join(&apos;-&apos;);</span><br><span class="line">console.log(result2); // 10-20-30-40-20</span><br></pre></td></tr></table></figure><h3 id="6-pop"><a href="#6-pop" class="headerlink" title="6.pop"></a>6.pop</h3><p><code>**pop()**</code> 方法从数组中<strong>删除最后一个元素</strong>，并返回该元素的值。此方法更改数组的长度，<strong>改变原数组</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [10, 20, 30, 40, 50];</span><br><span class="line">let result = arr1.pop();</span><br><span class="line">console.log(result); // 50</span><br><span class="line">console.log(arr1); // [10, 20, 30, 40];</span><br></pre></td></tr></table></figure><h3 id="7-push"><a href="#7-push" class="headerlink" title="7.push"></a>7.push</h3><p><code>**push()**</code> 方法将<strong>一个或多个元素添加到数组的末尾</strong>，并返回该数组的新长度，<strong>改变原数组</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [10, 20, 30, 40, 50];</span><br><span class="line">let result = arr1.push(60);</span><br><span class="line">console.log(result); // 6,返回数组长度</span><br><span class="line">console.log(arr1); // [10, 20, 30, 40, 50,60]</span><br><span class="line">arr1.push(70, 80);</span><br><span class="line">console.log(arr1); // [10, 20, 30, 40, 50,60,70, 80]</span><br></pre></td></tr></table></figure><h3 id="8-shift"><a href="#8-shift" class="headerlink" title="8.shift"></a>8.shift</h3><p><code>**shift()**</code> 方法从数组中<strong>删除第一个元素</strong>，并返回该元素的值。此方法更改数组的长度，<strong>改变原数组</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [10, 20, 30, 40, 50];</span><br><span class="line">let result = arr1.shift();</span><br><span class="line">console.log(result); // 10</span><br><span class="line">console.log(arr1); // [ 20, 30, 40, 50,60]</span><br></pre></td></tr></table></figure><h3 id="9-unshift"><a href="#9-unshift" class="headerlink" title="9.unshift"></a>9.unshift</h3><p><code>**unshift()**</code>方法将<strong>一个或多个元素添加到数组的开头</strong>，并返回该数组的新长度，<strong>改变原数组</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [10, 20, 30, 40, 50];</span><br><span class="line">let result = arr1.unshift(60, 70);</span><br><span class="line">console.log(result); // 7</span><br><span class="line">console.log(arr1); // [ 60, 70,20, 30, 40, 50]</span><br></pre></td></tr></table></figure><h3 id="10-splice"><a href="#10-splice" class="headerlink" title="10.splice"></a>10.splice</h3><p><code>**splice()**</code> 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。<strong>此方法会改变原数组</strong>。</p><p> 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</p><h4 id="1-删除一个数值"><a href="#1-删除一个数值" class="headerlink" title="1.删除一个数值"></a>1.删除一个数值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [10, 20, 30, 40, 50];</span><br><span class="line">let result = arr1.splice(2, 1); // 索引2处，删除一个元素，即删除30</span><br><span class="line">console.log(result); // [30]，返回删除的数组</span><br><span class="line">console.log(arr1); // 原数组也发生变化</span><br></pre></td></tr></table></figure><h4 id="2-删除并在原处新增一个数值"><a href="#2-删除并在原处新增一个数值" class="headerlink" title="2.删除并在原处新增一个数值"></a>2.删除并在原处新增一个数值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [10, 20, 30, 40, 50];</span><br><span class="line">let result = arr1.splice(2, 1, &apos;修改&apos;); // 索引2处，删除一个</span><br><span class="line">console.log(result); // [30]，返回删除的数组</span><br><span class="line">console.log(arr1); // 原数组也发生变化 [10, 20, &apos;修改&apos;, 40, 50]</span><br></pre></td></tr></table></figure><h4 id="3-索引新增一个元素"><a href="#3-索引新增一个元素" class="headerlink" title="3.索引新增一个元素"></a>3.索引新增一个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [10, 20, 30, 40, 50];</span><br><span class="line">let result = arr1.splice(2, 0, &apos;新增&apos;); // 索引2处，新增</span><br><span class="line">console.log(result); // []，返回删除的数组</span><br><span class="line">console.log(arr1); // 原数组也发生变化 [10, 20, &apos;修改&apos;,30， 40, 50]</span><br></pre></td></tr></table></figure><h3 id="11-slice"><a href="#11-slice" class="headerlink" title="11.slice"></a>11.slice</h3><p><code>**slice()**</code> 方法返回一个新的数组对象，这一对象是一个由 <code>start</code> 和 <code>end</code> 决定的原数组的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Shallow_copy" target="_blank" rel="noopener">浅拷贝</a>（包括 <code>start</code>，不包括 <code>end</code>），其中 <code>start</code> 和 <code>end</code> 代表了数组元素的索引。原始数组不会被改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const animals = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;elephant&apos;];</span><br><span class="line"></span><br><span class="line">// 返回从索引2到结尾的元素</span><br><span class="line">console.log(animals.slice(2));</span><br><span class="line">// Expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br><span class="line"></span><br><span class="line">// 返回索引从2到4的元素，但包含4</span><br><span class="line">console.log(animals.slice(2, 4));</span><br><span class="line">// Expected output: Array [&quot;camel&quot;, &quot;duck&quot;]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(1, 5));</span><br><span class="line">// Expected output: Array [&quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(-2));</span><br><span class="line">// Expected output: Array [&quot;duck&quot;, &quot;elephant&quot;]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2, -1));</span><br><span class="line">// Expected output: Array [&quot;camel&quot;, &quot;duck&quot;]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice());</span><br><span class="line">// Expected output: Array [&quot;ant&quot;, &quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br></pre></td></tr></table></figure><h3 id="12-reverse"><a href="#12-reverse" class="headerlink" title="12.reverse"></a>12.reverse</h3><p><code>**reverse()**</code>方法将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [5, 3, 1, 8, 6];</span><br><span class="line">console.log(arr1.reverse()); // [6, 8, 1, 3, 5]</span><br><span class="line">console.log(arr1); // [6, 8, 1, 3, 5]</span><br></pre></td></tr></table></figure><h3 id="13-sort"><a href="#13-sort" class="headerlink" title="13.sort"></a>13.sort</h3><p><code>**sort()**</code> 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字 符串，然后比较它们的 UTF-16 代码单元值序列时构建的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [5, 3, 1, 8, 6, 11];</span><br><span class="line">console.log(arr1.sort()); // [1, 11, 3, 5, 6, 8]</span><br><span class="line">console.log(arr1); // [1, 11, 3, 5, 6, 8]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;01-for和forEach&quot;&gt;&lt;a href=&quot;#01-for和forEach&quot; class=&quot;headerlink&quot; title=&quot;01-for和forEach&quot;&gt;&lt;/a&gt;01-for和forEach&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;for循环是最常规最通用的一种循环遍历方法；&lt;/li&gt;
&lt;li&gt;forEach方法是一个高阶函数，会引入额外的函数调用开销，forEach会改变原数组；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-性能上的比较&quot;&gt;&lt;a href=&quot;#1-性能上的比较&quot; class=&quot;headerlink&quot; title=&quot;1.性能上的比较&quot;&gt;&lt;/a&gt;1.性能上的比较&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for&amp;gt;forEach&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;for循环直接操作索引，没有额外的函数调用和上下文，所以性能是最快的&lt;/li&gt;
&lt;li&gt;for可以使用break终止，forEach不支持跳出循环&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尝试分别用&lt;code&gt;for&lt;/code&gt;和&lt;code&gt;forEach&lt;/code&gt;循环遍历数量级比较大的数组，&lt;code&gt;for&lt;/code&gt;循环用时&lt;code&gt;小于``forEach&lt;/code&gt;的执行时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="数组" scheme="https://mengnn.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>web3.0 是未来十年的风口吗？</title>
    <link href="https://mengnn.cn/web3.0%20%E6%98%AF%E6%9C%AA%E6%9D%A5%E5%8D%81%E5%B9%B4%E7%9A%84%E9%A3%8E%E5%8F%A3%E5%90%97/"/>
    <id>https://mengnn.cn/web3.0 是未来十年的风口吗/</id>
    <published>2024-09-14T07:47:34.646Z</published>
    <updated>2024-09-14T07:52:19.111Z</updated>
    
    <content type="html"><![CDATA[<p>近来，一个备受关注的问题频繁被提出：<em>Web3.0 是否将成为未来十年的风口？</em>历史总是最好的老师，正如没有人能在牛市到来之前预测它的出现，我们往往只有在趋势成为过去时，才能确认它的价值。</p><p>然而，凭借互联网从业者的敏锐直觉，答案似乎是肯定的。从近年来国家软考考试的教材和试题中，我们可以发现区块链、加密货币、元宇宙等概念越来越多地出现在我们的视野中。国家也在积极推动区块链技术和元宇宙的发展。因此，如果我们要展望未来十年的发展趋势，Web3.0无疑是其中的关键之一。Web3.0 有望成为连接物理世界与数字世界的桥梁，使用户能够安全、直接地在线进行交易。</p><a id="more"></a><p>从发展的脉络来看，Web3.0 目前仍处于起步阶段，可以类比为互联网行业的 2000 年代初期。那时，Web2.0 技术如社交网络、博客等开始崭露头角，但尚未完全成熟和普及。同样，Web3.0 技术如区块链、NFT（非同质化代币）、DAO（去中心化自治组织）等正在快速发展，但许多应用仍在探索之中，尚未实现大规模普及。因此，现在正是学习 Web3.0 技术的最佳时机，未来将迎来巨大的红利期。</p><p>Web3.0 的概念自提出至今已有十余年，但为何参与人数和应用尚未如雨后春笋般涌现？技术门槛是一个主要障碍。<strong>Web3.0 应用开发涉及区块链技术、加密技术、智能合约编程等</strong>，这些技术的门槛相对较高。相比之下，Web2.0 应用开发主要基于传统的 Web 技术栈，如 HTML、CSS、JavaScript、数据库技术等，这些技术已经相对成熟，开发和维护也相对容易。许多人对区块链和智能合约的概念可能仍然感到困惑，高技术门槛也是阻碍 Web3.0 发展的一个重要因素。但正如美味不怕晚，随着参与人数的指数级增长、社区的不断完善、技术门槛的不断降低，Web3.0 的全民参与时代可能很快就会到来。</p><p><strong>Web3 代表着下一代互联网的发展方向</strong>，其中区块链技术为分布式应用程序（dApp）和智能合约提供动力。Web3 应用程序开发是一种构建互联网应用程序的新方法，旨在为用户提供更安全、高效、可靠的体验。它利用区块链技术，这是一种去中心化的分布式账本技术，能够以更少的中介存储数据和执行交易。该技术还允许开发比传统网络平台上构建的应用程序更安全、更私密的去中心化应用程序（dApp）。</p><p>Web3 和区块链技术的结合预示着一种更安全、更高效的在线交易方式。通过利用区块链技术的优势，企业可以创建更安全的在线支付系统、智能合约和自动化交易。通过使用分布式账本技术，企业可以创建一个更加透明和可靠的系统来跟踪支付和交易。</p><p>展望未来，我们可以预见 Web3 和区块链技术将被用于创建更安全、更高效的分布式应用程序。区块链技术将促进智能合约和分布式应用程序的开发，使开发者能够构建用于安全可靠地传输数据、存储资产和完成交易的应用程序。通过使用分布式账本技术，企业将能够创建一个更安全可靠的系统来跟踪支付和交易。此外，区块链技术可用于为开发者创建一个安全、分散的平台，以构建不受审查和操纵的应用程序。</p><p>目前，<strong>Web3.0 正从理想走向现实</strong>，越来越多的项目和应用正在逐步落地。它将带来前所未有的机遇和挑战。对于那些渴望在数字世界中探索新可能的人来说，现在正是最佳时机。让我们拥抱 Web3.0，共同开启一个更加开放、公平和互联的数字新时代。</p><p><a href="https://mp.weixin.qq.com/s/LfsPVUhohdXajN8Zm_gDGw" target="_blank" rel="noopener">点击查看更多内容</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近来，一个备受关注的问题频繁被提出：&lt;em&gt;Web3.0 是否将成为未来十年的风口？&lt;/em&gt;历史总是最好的老师，正如没有人能在牛市到来之前预测它的出现，我们往往只有在趋势成为过去时，才能确认它的价值。&lt;/p&gt;
&lt;p&gt;然而，凭借互联网从业者的敏锐直觉，答案似乎是肯定的。从近年来国家软考考试的教材和试题中，我们可以发现区块链、加密货币、元宇宙等概念越来越多地出现在我们的视野中。国家也在积极推动区块链技术和元宇宙的发展。因此，如果我们要展望未来十年的发展趋势，Web3.0无疑是其中的关键之一。Web3.0 有望成为连接物理世界与数字世界的桥梁，使用户能够安全、直接地在线进行交易。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="web3.0" scheme="https://mengnn.cn/tags/web3-0/"/>
    
  </entry>
  
  <entry>
    <title>解决Win11点击鼠标右键，“新建”选项消失的解决方法</title>
    <link href="https://mengnn.cn/%E8%A7%A3%E5%86%B3Win11%E7%82%B9%E5%87%BB%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%EF%BC%8C%E2%80%9C%E6%96%B0%E5%BB%BA%E2%80%9D%E9%80%89%E9%A1%B9%E6%B6%88%E5%A4%B1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://mengnn.cn/解决Win11点击鼠标右键，“新建”选项消失的解决方法/</id>
    <published>2024-08-13T08:33:41.004Z</published>
    <updated>2024-08-13T08:38:57.934Z</updated>
    
    <content type="html"><![CDATA[<p>每次更新Wind11后，就会莫名奇妙的丢失一些功能。比如桌面鼠标右键“新建”功能时常消失。我本人已经遇到过两次了。</p><p>不是每次更新都会丢失，但丢失的功能的大多原因都是因为更新。还有一个原因是删除软件时注册表内的一些文件删除了。</p><p>只需要复制下面一段内容，以管理员运行cmd，然后输入下面这段代码就可以解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKEY_CLASSES_ROOT\Directory\Background\shellex\ContextMenuHandlers\New&quot; /ve /t REG_SZ /d &#123;D969A300-E7FF-11d0-A93B-00A0C90F2719&#125; /f</span><br></pre></td></tr></table></figure><p>运行后，无论是在桌面，还是在其他文件夹内，鼠标右键的“新建”功能都能完美修复。</p><p>收藏下来吧，省得下次又有问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每次更新Wind11后，就会莫名奇妙的丢失一些功能。比如桌面鼠标右键“新建”功能时常消失。我本人已经遇到过两次了。&lt;/p&gt;
&lt;p&gt;不是每次更新都会丢失，但丢失的功能的大多原因都是因为更新。还有一个原因是删除软件时注册表内的一些文件删除了。&lt;/p&gt;
&lt;p&gt;只需要复制下面一段内
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://mengnn.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="工具" scheme="https://mengnn.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>电影版《云边有个小卖部》：不哭着走出影院的都是勇士</title>
    <link href="https://mengnn.cn/%E7%94%B5%E5%BD%B1%E7%89%88%E3%80%8A%E4%BA%91%E8%BE%B9%E6%9C%89%E4%B8%AA%E5%B0%8F%E5%8D%96%E9%83%A8%E3%80%8B%EF%BC%9A%E4%B8%8D%E5%93%AD%E7%9D%80%E8%B5%B0%E5%87%BA%E5%BD%B1%E9%99%A2%E7%9A%84%E9%83%BD%E6%98%AF%E5%8B%87%E5%A3%AB/"/>
    <id>https://mengnn.cn/电影版《云边有个小卖部》：不哭着走出影院的都是勇士/</id>
    <published>2024-06-24T02:09:05.812Z</published>
    <updated>2024-06-24T02:27:01.374Z</updated>
    
    <content type="html"><![CDATA[<p>周末去看了刚上映的电影版《云边有个小卖部》，不哭着走出影院的都是勇士。</p><a id="more"></a><p>我是真没控制住，第一次抽泣应该是在程霜给外婆读刘十三小时候的得奖作文的时候。具体的来说应该是读程霜修改过的小作文。从哪开始，一发不可收拾。甚至单纯的听到拖拉机突突突的声音，都令人泣不成声。</p><p>那熟悉又陌生的拖拉机声，小时候在熟悉不过了。哪熟悉又陌生的突突突声响起，小时候的事情无限循环在脑海中：曾祖父曾祖母、外公外婆、爷爷奶奶…还有那满地金黄的麦子……</p><p>好像不仅仅我把电影代入了，旁边的小伙伴似乎也在抹眼泪，都在安静的抹眼泪。</p><p>电影结束后，也看了很多评论。最深刻的就是：大家都哭了，虽然没有打高分的冲动，但大家都哭了。</p><p>是呀，电影没有故意的煽情，但大家都看哭了。</p><p>外婆说：祖祖辈辈埋葬的地方，就是故乡。</p><p>而现在：故乡已经变成了，有你爱的人在的地方就是故乡。</p><p>但后来想想，也不矛盾，毕竟我们爱的人，陪伴我们童年的人都在故乡。但，好像有太久没回故乡了……</p><p>人为什么会感到不安？对于不可预见的未来，一想到“该怎么办”“发生不好的事该怎么处理”“失败了该如何应对”时，就会感到不安，甚至失眠，甚至于对生活失去希望，那人间到底值不值得？我们辛苦一遭来到这个人世间又值不值得？</p><p>周末去看了刚上映的电影版《云边有个小卖部》，不哭着走出影院的都是勇士。</p><!--more--><p>我是真没控制住，第一次抽泣应该是在程霜给外婆读刘十三小时候的得奖作文的时候。具体的来说应该是读程霜修改过的小作文。从哪开始，一发不可收拾。甚至单纯的听到拖拉机突突突的声音，都令人泣不成声。</p><p>那熟悉又陌生的拖拉机声，小时候在熟悉不过了。哪熟悉又陌生的突突突声响起，小时候的事情无限循环在脑海中：曾祖父曾祖母、外公外婆、爷爷奶奶…还有那满地金黄的麦子……</p><p>好像不仅仅我把电影代入了，旁边的小伙伴似乎也在抹眼泪，都在安静的抹眼泪。</p><p>电影结束后，也看了很多评论。最深刻的就是：大家都哭了，虽然没有打高分的冲动，但大家都哭了。</p><p>是呀，电影没有故意的煽情，但大家都看哭了。</p><p>外婆说：祖祖辈辈埋葬的地方，就是故乡。</p><p>而现在：故乡已经变成了，有你爱的人在的地方就是故乡。</p><p>但后来想想，也不矛盾，毕竟我们爱的人，陪伴我们童年的人都在故乡。但，好像有太久没回故乡了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末去看了刚上映的电影版《云边有个小卖部》，不哭着走出影院的都是勇士。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://mengnn.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="云边有个小卖部" scheme="https://mengnn.cn/tags/%E4%BA%91%E8%BE%B9%E6%9C%89%E4%B8%AA%E5%B0%8F%E5%8D%96%E9%83%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于uni-app框架开发的多端小程序【少儿国学经典指南】</title>
    <link href="https://mengnn.cn/%E5%9F%BA%E4%BA%8Euni-app%E5%BC%80%E5%8F%91%E7%9A%84%E5%B0%91%E5%84%BF%E5%9B%BD%E5%AD%A6%E7%BB%8F%E5%85%B8%E6%8C%87%E5%8D%97%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>https://mengnn.cn/基于uni-app开发的少儿国学经典指南小程序/</id>
    <published>2024-04-01T03:36:56.270Z</published>
    <updated>2024-04-01T05:45:40.641Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间基于uni-app框架开发了一款关于国学经典的小程序【<a href="https://guoxue.mengxyz.com/#/" target="_blank" rel="noopener">少儿国学经典指南</a>】，已经上架web端，微信小程序端以及抖音小程序。</p><p>关于上架小程序，可为一波三折，备案认证的却花了不少时间。但最近发现，小程序备案快了很多，而且审核什么的也比较容易通过，互联网是在不断进步的。</p><p><img src="https://cdn.mengxyz.com/blog/shaoerguoxue.png" alt></p><a id="more"></a><p>在数字化浪潮席卷的今天，传统文化与现代科技的融合已成为一种新趋势。作为一位小程序开发者，一直想开发一款结合传统国学与现代科技的工具——“少儿国学经典指南”小程序。</p><p>这款小程序旨在轻松愉快的氛围中学习国学知识，感受中华文化的博大精深。它汇聚了丰富的国学经典内容，包括《三字经》、《百家姓》、《千字文》、《论语》、《孟子》等经典读物，让我们领略传统文化的魅力。</p><p>“少儿国学经典指南”小程序的特点之一是互动性强。它采用了动画、游戏等多种形式，将国学知识融入到有趣的互动中，让孩子们在玩乐中学习，提升学习兴趣。同时，小程序还设有智能语音朗读功能，让孩子们在听读中感受语言的韵律美，培养语言表达能力。</p><p>除了内容丰富、形式多样外，这款小程序还注重个性化学习。它根据孩子们的年龄、兴趣和学习进度，智能推荐适合的学习内容，让每个孩子都能找到适合自己的学习路径。此外，小程序还提供了学习记录和进步报告功能，让家长能够随时了解孩子的学习情况，共同见证孩子的成长。</p><p>在“少儿国学经典”小程序中，孩子们不仅能够学习到国学知识，还能够培养品德修养、提升人文素养。通过学习国学经典，孩子们能够了解中华民族的历史传统、道德观念和价值观念，形成正确的世界观、人生观和价值观。</p><p>作为一款集教育性、趣味性、互动性于一体的小程序，“少儿国学经典指南”为广大家长和孩子提供了一个全新的学习平台。让我们一起携手，传承中华文化，点亮智慧之光，为孩子们的成长助力！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一段时间基于uni-app框架开发了一款关于国学经典的小程序【&lt;a href=&quot;https://guoxue.mengxyz.com/#/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;少儿国学经典指南&lt;/a&gt;】，已经上架web端，微信小程序端以及抖音小程序。&lt;/p&gt;
&lt;p&gt;关于上架小程序，可为一波三折，备案认证的却花了不少时间。但最近发现，小程序备案快了很多，而且审核什么的也比较容易通过，互联网是在不断进步的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.mengxyz.com/blog/shaoerguoxue.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="uni-app" scheme="https://mengnn.cn/tags/uni-app/"/>
    
      <category term="小程序" scheme="https://mengnn.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>uniapp云开发发布小程序云函数报错</title>
    <link href="https://mengnn.cn/uniCloud%E4%BA%91%E5%BC%80%E5%8F%91%E5%8F%91%E5%B8%83%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%87%BD%E6%95%B0%E6%8A%A5%E9%94%99/"/>
    <id>https://mengnn.cn/uniCloud云开发发布小程序云函数报错/</id>
    <published>2024-01-11T03:26:32.687Z</published>
    <updated>2024-01-11T06:32:42.381Z</updated>
    
    <content type="html"><![CDATA[<p><strong>“连接本地调试服务失败，请检查客户端是否和主机在同一局域网下”</strong>，这是uniCloud云开发发布小程序后，正式环境下访问的报错情况。在本地调试都ok的情况下，以及绑定所有的域名白名单后发现的错误。</p><p><img src="https://cdn.mengxyz.com/blog/20240111-1.png" alt="报错"></p><a id="more"></a><p>经过一番开发文档查找，终于找到了原因，一个我们太容易忽略的原因：</p><p>在HBuilderX编辑器发布小程序的时候，要通过<strong>【发行】-&gt; 【小程序-】</strong>按钮进行发不到各大小程序平台的开发工具中，然后在各大小程序开发工具上面进行上传代码发布。而不是通过运行按钮，运行到各小程序平台然后进行发布。后者就会出现上面的报错情况。</p><p><img src="https://cdn.mengxyz.com/blog/20240111-2.png" alt="运行"></p><p>可以通过运行 -&gt; 运行到小程序 来进行预览，但是<strong><u>发布到正式小程序环境的时候一定要通过</u></strong>：<strong>【发行】-&gt; 【小程序】</strong>的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;“连接本地调试服务失败，请检查客户端是否和主机在同一局域网下”&lt;/strong&gt;，这是uniCloud云开发发布小程序后，正式环境下访问的报错情况。在本地调试都ok的情况下，以及绑定所有的域名白名单后发现的错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.mengxyz.com/blog/20240111-1.png&quot; alt=&quot;报错&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="uni-app" scheme="https://mengnn.cn/tags/uni-app/"/>
    
      <category term="uniCloud" scheme="https://mengnn.cn/tags/uniCloud/"/>
    
  </entry>
  
  <entry>
    <title>今天我吃什么：让选择不再困难</title>
    <link href="https://mengnn.cn/eatWhat/"/>
    <id>https://mengnn.cn/eatWhat/</id>
    <published>2023-12-29T02:22:57.256Z</published>
    <updated>2023-12-29T02:48:24.339Z</updated>
    
    <content type="html"><![CDATA[<p>选择困难症？每天都在纠结吃什么？外卖、快餐、还是食堂的那些熟悉菜式？今天，我要为大家介绍一款微信小程序——“今天我吃什么”，让你轻松解决选择困难，享受美食的乐趣！</p><p><img src="https://cdn.mengxyz.com/blog/eatWhat.png" alt></p><a id="more"></a><h3 id="一、大转盘，随心转出你的选择"><a href="#一、大转盘，随心转出你的选择" class="headerlink" title="一、大转盘，随心转出你的选择"></a>一、大转盘，随心转出你的选择</h3><p>厌倦了日常的菜式？试试“大转盘”功能！随机转出各地特色美食，给你不一样的味蕾体验。每转一次，都是新的惊喜，让你的选择充满趣味性。</p><h3 id="二、宫格选，多款美食任你挑"><a href="#二、宫格选，多款美食任你挑" class="headerlink" title="二、宫格选，多款美食任你挑"></a>二、宫格选，多款美食任你挑</h3><p>“宫格选”功能汇集了各类美食，让你在多个选项中挑选心仪的美食。无论是中式还是西式，都能满足你的口味需求。</p><h3 id="三、中国各地特色美食推荐"><a href="#三、中国各地特色美食推荐" class="headerlink" title="三、中国各地特色美食推荐"></a>三、中国各地特色美食推荐</h3><p>这款小程序汇聚了中国各地的特色美食，行走的中国美食地图。在你出游到一个陌生城市的时候，打开美食地图就能感受到当地的特色美食，帮助你快速定位选择你感兴趣的美食。</p><h3 id="四、健康饮食食谱，吃得营养又健康"><a href="#四、健康饮食食谱，吃得营养又健康" class="headerlink" title="四、健康饮食食谱，吃得营养又健康"></a>四、健康饮食食谱，吃得营养又健康</h3><p>想要吃得健康又营养？“健康饮食食谱”功能为你提供专业的饮食建议。无论是减肥塑身还是养生保健，都能找到适合你的食谱。健康早餐？营养晚餐？减肥减脂餐？一查便知，更多的选择和挑战等着你来。</p><h3 id="五、一键下单，轻松享受美食"><a href="#五、一键下单，轻松享受美食" class="headerlink" title="五、一键下单，轻松享受美食"></a>五、一键下单，轻松享受美食</h3><p>选择好心仪的美食后，只需简单操作，便可实现一键下单。无论是外卖还是堂食，都能轻松满足你的需求。让你享受美食的同时，省去选择的烦恼。</p><p>选择“今天我吃什么”，让每天的饮食选择变得简单而愉快。再也不用为吃什么而犯愁，每一天都能享受到美食带来的快乐。现在就打开微信，搜索“今天我吃什么”，开始你的美食之旅吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;选择困难症？每天都在纠结吃什么？外卖、快餐、还是食堂的那些熟悉菜式？今天，我要为大家介绍一款微信小程序——“今天我吃什么”，让你轻松解决选择困难，享受美食的乐趣！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.mengxyz.com/blog/eatWhat.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://mengnn.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="今天我吃什么" scheme="https://mengnn.cn/tags/%E4%BB%8A%E5%A4%A9%E6%88%91%E5%90%83%E4%BB%80%E4%B9%88/"/>
    
      <category term="微信小程序" scheme="https://mengnn.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>mpvue项目和原生微信小程序框架合并开发</title>
    <link href="https://mengnn.cn/mpvue%E9%A1%B9%E7%9B%AE%E5%92%8C%E5%8E%9F%E7%94%9F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E5%90%88%E5%B9%B6%E5%BC%80%E5%8F%91/"/>
    <id>https://mengnn.cn/mpvue项目和原生微信小程序框架合并开发/</id>
    <published>2023-12-06T03:38:05.500Z</published>
    <updated>2023-12-06T04:03:54.628Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间项目遇到一个需求：需要把我们做的原生微信小程序代码和客户用<a href="http://mpvue.com/" target="_blank" rel="noopener">mpvue框架</a>开发的小程序代码进行融合。也就是之前需要两个微信小程序来回跳转传输的，现在合并到一个小程序中。</p><p>开发之前查了一些资料，不管是微信原生还是mpvue框架都支持分包。但对于一个更熟于原生框架开发的来说，更想尝试一下自己的思路方法：</p><a id="more"></a><ol><li>在mpvue项目打包之前，修改mpvue项目的跳转逻辑</li><li>对mpvue项目进行build打包</li><li>把mpvue打包后的文件和原生小程序页面进行合并</li><li>配置原生微信小程序app.json文件</li></ol><p>思路有了，就开始干，扒代码。</p><h2 id="mpvue文件"><a href="#mpvue文件" class="headerlink" title="mpvue文件"></a>mpvue文件</h2><p>针对于没有进行npm run build打包的mpvue源文件进行修改：</p><ul><li>修改appid：把appid修改成要合并后的appid</li><li>修改src文件下所有有关原来两个小程序跳转的方法（原方法可能是通过wx.navigateToMiniProgram进行小程序之间的跳转的，修改成小程序页面之间的跳转方法，比如：wx.navigateTo）</li><li>进行npm run build进行打包，这个会在dist文件夹下生成对应的打包文件（比如你提前设置好的打包命令：npm run build:wx，会在dist下面生成wx文件夹及对应打包后的文件）</li></ul><h2 id="融合原生小程序代码"><a href="#融合原生小程序代码" class="headerlink" title="融合原生小程序代码"></a>融合原生小程序代码</h2><p>要确定原生小程序pages下面的文件和mpvue项目pages文件下的文件没有命名重复的，也一定不能重复。</p><ul><li>把mpvue打包后后的wx文件夹下面的common文件夹复制到原生小程序根目录下</li><li>把mpvue打包后的wx文件夹下的pages文件夹下面的文件复制到原生小程序pages文件夹下面</li><li>修改原生小程序app.json文件内容，配置“pages”:[]项，把新增的pages文件夹下的文件路径配置在app.json文件内</li><li>把mpvue打包后的wx文件夹下的app.js文件内容复制到原生小程序的app.js文件内</li><li>把mpvue打包后的wx文件夹下的app.wxss文件内容复制到原生小程序的app.wxss文件内</li></ul><p>到这里，基本算是完成了，运行微信开发者工具看看你的项目如何。当然需要根据你的首页需求，来修改要展示的首页路径。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间项目遇到一个需求：需要把我们做的原生微信小程序代码和客户用&lt;a href=&quot;http://mpvue.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mpvue框架&lt;/a&gt;开发的小程序代码进行融合。也就是之前需要两个微信小程序来回跳转传输的，现在合并到一个小程序中。&lt;/p&gt;
&lt;p&gt;开发之前查了一些资料，不管是微信原生还是mpvue框架都支持分包。但对于一个更熟于原生框架开发的来说，更想尝试一下自己的思路方法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="mpvue框架" scheme="https://mengnn.cn/tags/mpvue%E6%A1%86%E6%9E%B6/"/>
    
      <category term="微信原生小程序" scheme="https://mengnn.cn/tags/%E5%BE%AE%E4%BF%A1%E5%8E%9F%E7%94%9F%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>uniapp+uView2.0自定义底部tabbar导航</title>
    <link href="https://mengnn.cn/uniapp%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%95%E9%83%A8tabbar%E5%AF%BC%E8%88%AA/"/>
    <id>https://mengnn.cn/uniapp自定义底部tabbar导航/</id>
    <published>2023-11-25T16:00:00.000Z</published>
    <updated>2023-11-26T08:42:12.123Z</updated>
    
    <content type="html"><![CDATA[<p>在正式开始代码之前，我们首先了解一下<code>uni-app</code>的<code>easycom</code>机制。传统vue项目开发，引用组件需要<code>导入 - 注册 - 使用</code>三个步骤。而<code>uni-app</code>的<code>easycom</code>机制，将组件引用进一步优化，开发者只管使用，无需考虑导入和注册。</p><a id="more"></a><p>即只需要按照uni-app的easycom机制规则（根目录下创建components文件夹，components文件夹内创建组件文件夹，组件文件夹内创建和文件夹同名的vue文件）创建组件，可以在页面中直接引用组件，省去了导入注册的过程。但是需要注意的是：<strong>组件命名规则为“my-component”，通过“-”连接的方式命名</strong>。</p><h3 id="配置pages-json文件，确定tabbar页面"><a href="#配置pages-json文件，确定tabbar页面" class="headerlink" title="配置pages.json文件，确定tabbar页面"></a>配置pages.json文件，确定tabbar页面</h3><p>首先需要在根目录下的pages.json文件中配置tabbar属性，配置你的底部tabbar页面。</p><p>在属性tabBar下面配置list数组，数组中只需要配置pagePath和text即可，其他内容自定义就行。</p><p>注意：有几个tabbar页面就配置几个，否则会报错。以下面两个为例。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// pages.json</span><br><span class="line">"tabBar": &#123;</span><br><span class="line">"list": [&#123;</span><br><span class="line">"pagePath": "pages/index/index",</span><br><span class="line">"text": "首页"</span><br><span class="line">&#125;, &#123;</span><br><span class="line">"pagePath": "pages/my/my",</span><br><span class="line">             "text": "我的"</span><br><span class="line">&#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="创建tabbar组件"><a href="#创建tabbar组件" class="headerlink" title="创建tabbar组件"></a>创建tabbar组件</h3><p>在项目根目录下创建<strong>components</strong>文件夹，然后在该文件下面创建同名目录的组件tab-bar，即文件夹名字为tab-bar，文件名字为tab-bar.vue。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// tab-bar.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;u-tabbar @change=&quot;changeTab&quot; :value=&quot;tabIndex&quot; :fixed=&quot;true&quot; :placeholder=&quot;true&quot; :safeAreaInsetBottom=&quot;true&quot; activeColor=&quot;#09C272&quot; inactiveColor=&quot;#7d7e80&quot;&gt;</span><br><span class="line">&lt;u-tabbar-item :text=&quot;item.text&quot; :name=&quot;item.name&quot; icon=&quot;home&quot; v-for=&quot;item in tabList&quot; v-bind:key=&quot;item.name&quot; @click=&quot;tabClick(item.path)&quot;&gt;&lt;/u-tabbar-item&gt;</span><br><span class="line">&lt;/u-tabbar&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name: &apos;tabbar&apos;,</span><br><span class="line">props: &#123;</span><br><span class="line">tabIndex: &#123;</span><br><span class="line">type: Number,</span><br><span class="line">default: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">// tabIndex: &apos;/pages/index/index&apos;,</span><br><span class="line">tabList: [</span><br><span class="line">&#123;</span><br><span class="line">text: &apos;首页&apos;,</span><br><span class="line">name: 0,</span><br><span class="line">icon: &apos;home&apos;,</span><br><span class="line">path: &apos;/pages/index/index&apos;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">text: &apos;我的&apos;,</span><br><span class="line">name: 1,</span><br><span class="line">icon: &apos;account&apos;,</span><br><span class="line">path: &apos;/pages/my/my&apos;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">changeTab(e) &#123;&#125;,</span><br><span class="line">tabClick(path) &#123;</span><br><span class="line">// console.log(e);</span><br><span class="line">uni.switchTab(&#123;</span><br><span class="line">url: path</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上面代码为完成的配合uView框架的Tabbar 底部导航栏组件来完成的自定义文件。其中props属性中的tabIndex字段为当前选中的索引，通过tabbar主页面传递过来的索引，来选中当前标签。主要用来解决自定义组件跳转时不能及时选中组件的bug。</p><p>自定义组件中的其他参数属性，可转移<a href="https://www.uviewui.com/components/tabbar.html" target="_blank" rel="noopener">uView官网</a>详情了解，这里不做过多赘述。</p><h3 id="使用tabbar组件"><a href="#使用tabbar组件" class="headerlink" title="使用tabbar组件"></a>使用tabbar组件</h3><p>然后就是在tabbar页面引入自定义的tabbar组件。本案例中实在pages/index/index和pages/my/my文件中引入tabbar组件。以index.vue为例。直接引入”<tab-bar :tabindex="0"></tab-bar>“组件即可，然后传入当前页面索引值即可，简单明了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// pages/index/index</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;tab-bar :tabIndex=&quot;0&quot;&gt;&lt;/tab-bar&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>这个时候打开你会发现，自定义导航完美适配，而且比原生导航好看很多。</p><h3 id="避免的小bug"><a href="#避免的小bug" class="headerlink" title="避免的小bug"></a>避免的小bug</h3><p>当你引入自定义tabbar导航的时候，第一次加载进去你会发现原生导航会覆盖自定的导航。所以当页面启动的时候，隐藏到原生导航即可。</p><p>在App.vue文件的onLaunch方法中使用“uni.hideTabBar()”方法，隐藏原生的底部导航即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// App.vue</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">onLaunch: function () &#123;</span><br><span class="line">console.log(&apos;App Launch&apos;);</span><br><span class="line">uni.hideTabBar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在正式开始代码之前，我们首先了解一下&lt;code&gt;uni-app&lt;/code&gt;的&lt;code&gt;easycom&lt;/code&gt;机制。传统vue项目开发，引用组件需要&lt;code&gt;导入 - 注册 - 使用&lt;/code&gt;三个步骤。而&lt;code&gt;uni-app&lt;/code&gt;的&lt;code&gt;easycom&lt;/code&gt;机制，将组件引用进一步优化，开发者只管使用，无需考虑导入和注册。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="uni-app" scheme="https://mengnn.cn/tags/uni-app/"/>
    
      <category term="uView" scheme="https://mengnn.cn/tags/uView/"/>
    
      <category term="tabbar" scheme="https://mengnn.cn/tags/tabbar/"/>
    
  </entry>
  
  <entry>
    <title>二级域名申请部署以及免费的SSL证书部署教程</title>
    <link href="https://mengnn.cn/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%85%8D%E8%B4%B9ssl%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E9%83%A8%E7%BD%B2/"/>
    <id>https://mengnn.cn/二级域名申请解析以及免费ssl证书申请部署/</id>
    <published>2023-11-18T16:00:00.000Z</published>
    <updated>2023-11-19T09:16:32.300Z</updated>
    
    <content type="html"><![CDATA[<p>所谓二级域名，肯定是基于你已经存在一级域名的前提下的。二级域名申请部署免费，不用在次购买。另外腾讯和阿里云都有免费的SSL证书可申请，所以部署SSL证书也是完全免费的。下面是一些关于二级域名申请部署及免费SSL证书申请部署的教程。</p><a id="more"></a><h3 id="二级域名申请"><a href="#二级域名申请" class="headerlink" title="二级域名申请"></a>二级域名申请</h3><p>登录到你已经购买的云服务商控制台，以腾讯云为例：进入到云解析（我的解析）页面 ；然后点击添加域名（前提是在该云服务商已经购买一级域名）；弹窗内填写你想要的二级域名（比如我的一级域名mengxyz.com，我想要的二级域名：guoxue.mengxyz.com）,弹窗内填入guoxue.mengxyz.com即可。</p><p><img src="https://cdn.mengxyz.com/erjiyuming/1.png" alt="二级域名"></p><p>点击验证，进入到验证页面，这个页面等待片刻即可。</p><p><img src="https://cdn.mengxyz.com/erjiyuming/2.png" alt="二级域名"></p><p>验证完成后，会到验证DNS解析页面，这个时候你需要添加两条解析：一个是主机记录为www，记录类型为CNAME的云解析；另外一个是主机记录为@，记录类型为CNAME的云解析。其中记录值都是你要解析到的主机记录地址。</p><p>解析成功后，这个时候你访问你的二级域名就可正常访问了。</p><p><img src="https://cdn.mengxyz.com/erjiyuming/3.png" alt="二级域名"></p><h3 id="免费SSL证书部署"><a href="#免费SSL证书部署" class="headerlink" title="免费SSL证书部署"></a>免费SSL证书部署</h3><p>首先你可以在腾讯云平台申请免费的证书。正确情况下腾讯云免费的 SSL 证书可以申请 50 个，而阿里云可以申请 20 个，每个证书的期限是一年。你可以看我上面的一篇文章详细了解<a href="https://mengxyz.com/%e9%9a%8f%e7%ac%94/%e8%85%be%e8%ae%af%e4%ba%91%e5%92%8c%e9%98%bf%e9%87%8c%e4%ba%91%e5%85%8d%e8%b4%b9%e7%9a%84ssl%e8%af%81%e4%b9%a6/" target="_blank" rel="noopener">如何申请免费的证书</a>。</p><p>控制台搜索SSL证书-我的证书，进入页面后点击申请免费证书（可以看到我有50个免费证书）</p><p><img src="https://cdn.mengxyz.com/erjiyuming/10.png" alt="二级域名"></p><p>然后根据要求填写你上面申请好的二级域名，以及邮箱，其他都默认即可。点击提交申请。进入到域名验证页面。这个时候会出现需要你手动为域名添加一条CNAME记录，其中主机记录以及记录值复制即可。</p><p><img src="https://cdn.mengxyz.com/erjiyuming/4.png" alt="二级域名"></p><p><img src="https://cdn.mengxyz.com/erjiyuming/5.png" alt="二级域名"></p><p>进入到你的域名界面，点进你需要部署SSL证书的域名，进行CNAME解析。解析步骤如文章中的第一部分，添加主机记录、CNAME记录类型，记录值为SSL证书界面提供的值即可。添加成功后，点击验证域名，等待片刻即可（有时候可能因为解析需要时间，较短时间内可能没有验证成功，你也可以点击重新选择验证方式，进行自动验证）。</p><p><img src="https://cdn.mengxyz.com/erjiyuming/6.png" alt="二级域名"></p><p>验证成功后，进入到你的SSL证书页面，上面显示<strong>已签发</strong>即表示已经成功。这个时候你就可以下载证书把证书部署到你的服务器上面了。点击下载，下载你需要的类型，部署对你对应的服务器上即可。</p><p><img src="https://cdn.mengxyz.com/erjiyuming/7.png" alt="二级域名"></p><p><img src="https://cdn.mengxyz.com/erjiyuming/8.png" alt="二级域名"></p><p><img src="https://cdn.mengxyz.com/erjiyuming/9.png" alt="二级域名"></p><p>以上就算全部完成所有申请部署流程。再次访问你的网站<a href="https://guoxue.mengxyz.com" target="_blank" rel="noopener">https://guoxue.mengxyz.com</a>    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓二级域名，肯定是基于你已经存在一级域名的前提下的。二级域名申请部署免费，不用在次购买。另外腾讯和阿里云都有免费的SSL证书可申请，所以部署SSL证书也是完全免费的。下面是一些关于二级域名申请部署及免费SSL证书申请部署的教程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://mengnn.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="域名" scheme="https://mengnn.cn/tags/%E5%9F%9F%E5%90%8D/"/>
    
      <category term="免费SSL证书" scheme="https://mengnn.cn/tags/%E5%85%8D%E8%B4%B9SSL%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>子子的一岁三字经：超乎想象的儿童学习能力</title>
    <link href="https://mengnn.cn/%E8%B6%85%E4%B9%8E%E6%83%B3%E8%B1%A1%E7%9A%84%E5%84%BF%E7%AB%A5%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B/"/>
    <id>https://mengnn.cn/超乎想象的儿童学习能力/</id>
    <published>2023-11-16T08:42:34.799Z</published>
    <updated>2023-11-16T08:46:34.921Z</updated>
    
    <content type="html"><![CDATA[<p>在一次家庭的视频通话中，我惊喜地发现，子子竟然能够背诵三字经了。我怀着半信半疑的心态，看着她在我面前“表演”。很难想象，这个刚刚一岁零八个月的小朋友，竟然能够背诵超过十五句的三字经。虽然视频里的声音有些模糊，但作为同样从小背诵三字经的我，还是能够理解她背的是正确的。</p><a id="more"></a><p>周末的时候，我亲自“测试”了子子。我带着游戏的心态让她背诵三字经，结果她流利地完成了。这让我真的相信了她的能力。她的记忆力真的超出了我的想象，毕竟她只是一个平时连超过五个字都说不清楚的小孩子。而这样的表现，真的不容易。</p><p>其实，类似的事情在子子一岁左右的时候就发生过。当时她还不太会说话，但是对于学习的行为已经非常强烈了。我们家里就买了很多小卡片（动物、水果类的），没事就给她指这是什么，那个叫什么。然后会排列在地板上，给她一个名字，让她指认。每天空闲的时候，我们就会教她认识一些卡片上的内容。</p><p>突然有一天，爸妈说子子能认识很多小动物和水果了。当时一岁的她，对我来说，不可能的事。然后老婆就拉着我看，地板上大概排列了九个小卡片，苹果、香蕉、橘子……然后给子子一个口令，然后她就能毫不犹豫的拿起对应的卡片。刚开始我还是不相信的，认为她是碰巧，或者平常爸妈教她的时候排列的有问题。所以就让我这个平常没有给她排列过的生人进行打乱排列。结果让我大吃一惊，子子在打乱随机后，拿对的成功率在百分之九十以上，虽然有时也会遇到错的，但失误率很低很低。当时子子才一岁，一岁能识十种水果和动物，在我看来，很难了。</p><p>上面两件事，的确让我对儿童的认知有很大改变。当然可能跟她爱学习也有很大关系吧。子子经常拉着我或者其他人教她读书，她会拉着你坐下来然后给你一本书指着书上的画画让你给她讲是什么。她虽然还不能完全表达她的意思，但她会指给你。你一旦给她讲起书上的内容，她会很认真且立刻就能安静下来。这一点作为爸爸来说真的很欣慰，毕竟她老爸上学的时候很不爱读书。</p><p>自从知道她会背三字经后，空闲的时候我就会在她面前朗诵一些古诗，以至于《静夜思》她在什么时候学会的我都不知道。有一天中午带她出去散步，我问子子说：床前明月光的下一句是什么呀？然后她就：床前明月光疑，是地上霜。举头望明月，低头思故乡。一口气背下来了，惊得我抱起她竖起大拇指。毕竟才一岁八个月。</p><p>小朋友的学习能力和记忆能力，也许远远超过你的想象。只不过它是一个隐藏资源，需要你去发掘。当然发掘也是基于兴趣爱好，过量或者会适得其反。适当引导也许会有更好的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一次家庭的视频通话中，我惊喜地发现，子子竟然能够背诵三字经了。我怀着半信半疑的心态，看着她在我面前“表演”。很难想象，这个刚刚一岁零八个月的小朋友，竟然能够背诵超过十五句的三字经。虽然视频里的声音有些模糊，但作为同样从小背诵三字经的我，还是能够理解她背的是正确的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://mengnn.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="儿童" scheme="https://mengnn.cn/tags/%E5%84%BF%E7%AB%A5/"/>
    
  </entry>
  
</feed>
